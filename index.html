<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>기술블로그</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="기술블로그"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="기술블로그"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="기술블로그"><meta property="og:url" content="https://tk-one.github.io/"><meta property="og:site_name" content="기술블로그"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://tk-one.github.io/img/og_image.png"><meta property="article:author" content="TK-one"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://tk-one.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tk-one.github.io"},"headline":"기술블로그","image":["https://tk-one.github.io/img/og_image.png"],"author":{"@type":"Person","name":"TK-one"},"publisher":{"@type":"Organization","name":"기술블로그","logo":{"@type":"ImageObject","url":"https://tk-one.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/androidstudio.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-124797892-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-124797892-1');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/rss2.xml" title="기술블로그" type="application/rss+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="기술블로그" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-07T13:21:13.000Z" title="07/03/2022, 22:21:13">2022-03-07</time>&nbsp;게시 됨</span><span class="level-item"><a class="link-muted" href="/categories/personal/">personal</a></span><span class="level-item">4분안에 읽기 (약 541 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/03/07/coronavirus-confirmed/">코로나 확진후기</a></h1><div class="content"><p>결론부터 말하자면 2022년 3월 3일 코로나19 양성판정을 받았다.<br>계속 언제, 어디서부터 감염되었는지 생각해봤는데 아무리 생각해도 잘 모르겠다.<br>간 곳이라고는 집앞에 있는 스터디카페밖에 없었고 그 스터디카페는 정말 큼지막해서 사람간의 동선도 거의 겹치지 않는다.  </p>
<p>확진받은 날인 3월 3일 아침에 일어났을때 평소보다 목이 조금 잠겨있었다.<br>이거 코로나인가..? 라고 생각은 들지 않았을만큼 아주 미세한 차이였고 그래도 뭔가 찝찝해서 아침에 집에 있는
키트를 사용하여 진단해본 결과 <strong>음성</strong>이 나왔다.<br>그래서 내가 확진되었다는 생각은 전혀 하지 못했지만, 오후에 갑자기 엄마가 확진판정을 받았다고 했다.<br>그 말을 듣자마자 나도 바로 PCR검사를 받으러 갔고 결과는 다음과 같다.</p>
<p><img src="/images/covid19-confirmed.jpg" alt="covid19 message"></p>
<p>흑흑흑..<br>처음에 카톡으로 알림이 왔을때 나한테 잘못온줄 알았다.<br><del>아니 내가 걸린다고?</del><br>심지어 당일 아침에 자가진단키트로는 음성이 나왔어서 더 예상을 못했던 것 같다.  </p>
<p>기가막히게 확진을 받은 다음날 새벽부터 오한이왔고 심한 목감기처럼 통증이 심해졌다.<br>회사에도 현 상황을 공유해드리고 아픈건 맞지만 어차피 재택근무이고 업무하는데에는 무리가 없다는 개인적인 판단하에 계속해서 재택근무를 하기로 결정했다.<br>감사하게도 회사에서 상비약을 마련해서 바로 퀵으로 보내주셨고 정말 많은 도움이 되었다.<br>양도 굉장히 많아서 우리가족 다같이 나눠먹었다.  </p>
<p>이제 자가격리가 3일 남았는데 얼른 끝났으면 좋겠다…<br>공부해야될게 산더미인데 스터디카페를 못간다니..  </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-05T12:59:06.000Z" title="05/03/2022, 21:59:06">2022-03-05</time>&nbsp;게시 됨</span><span class="level-item"><a class="link-muted" href="/categories/tool/">tool</a></span><span class="level-item">4분안에 읽기 (약 585 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/03/05/how-to-use-markdown/">마크다운(Markdown) 사용법</a></h1><div class="content"><p>이번 포스트는 markdown에 대해 알아보는 포스트입니다.<br>자주 사용하는 markdown 키워드들 위주로 정리하였습니다.  </p>
<h2 id="Italics-and-Bolds"><a href="#Italics-and-Bolds" class="headerlink" title="Italics and Bolds"></a>Italics and Bolds</h2><ul>
<li>Italics<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is _italic_</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>this is <em>italic</em></p>
<ul>
<li>Bolds<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is **bold**</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>this is <strong>bold</strong></p>
<ul>
<li>Italics and Bolds<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is **_italics and bolds_**</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>this is <strong><em>italics and bolds</em></strong></p>
<h2 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h2><ul>
<li>Header 1부터 6까지 지원한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># header 1</span><br><span class="line">## header 2</span><br><span class="line">### header 3</span><br><span class="line">#### header 4</span><br><span class="line">##### header 5</span><br><span class="line">###### header 6</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="header-1"><a href="#header-1" class="headerlink" title="header 1"></a>header 1</h1><h2 id="header-2"><a href="#header-2" class="headerlink" title="header 2"></a>header 2</h2><h3 id="header-3"><a href="#header-3" class="headerlink" title="header 3"></a>header 3</h3><h4 id="header-4"><a href="#header-4" class="headerlink" title="header 4"></a>header 4</h4><h5 id="header-5"><a href="#header-5" class="headerlink" title="header 5"></a>header 5</h5><h6 id="header-6"><a href="#header-6" class="headerlink" title="header 6"></a>header 6</h6><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><h4 id="inline-링크와-reference-링크가-있다"><a href="#inline-링크와-reference-링크가-있다" class="headerlink" title="inline 링크와 reference 링크가 있다."></a>inline 링크와 reference 링크가 있다.</h4><ul>
<li>inline link<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[블로그 바로가기](https://tk-one.github.io)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://tk-one.github.io">블로그 바로가기</a></p>
<ul>
<li>reference link<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Here&apos;s [블로그 바로가기][my github].</span><br><span class="line"></span><br><span class="line">[my github]: https://tk-one.github.io</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Here’s <a href="https://tk-one.github.io">블로그 바로가기</a>.  </p>
<h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><h4 id="이미지도-링크와-비슷하게-inline-이미지와-reference-이미지가-있다"><a href="#이미지도-링크와-비슷하게-inline-이미지와-reference-이미지가-있다" class="headerlink" title="이미지도 링크와 비슷하게 inline 이미지와 reference 이미지가 있다."></a>이미지도 링크와 비슷하게 inline 이미지와 reference 이미지가 있다.</h4><ul>
<li>inline image<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![alt text](url)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/images/markdown.png" alt="markdown"></p>
<ul>
<li>reference image<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![alt text][markdown image]</span><br><span class="line"></span><br><span class="line">[markdown image]: /images/markdown.png</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/images/markdown.png" alt="markdown"></p>
<ul>
<li>이미지의 width와 height를 직접 지정해야 하는 상황이면 HTML의 img tag를 직접 사용한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;/path&quot; width=&quot;500px&quot; height=&quot;300px&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/images/markdown.png" width="500px" height="300px"></p>
<h2 id="BlockQuotes"><a href="#BlockQuotes" class="headerlink" title="BlockQuotes"></a>BlockQuotes</h2><ul>
<li>BlockQuotes를 만들기 위해서는 앞에 caret(&gt;)을 넣어준다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; this is quotes.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>this is quotes.</p>
<ul>
<li>BlockQuotes안에서도 다른 markdown 문법을 사용할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; this is _italic_.</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<p>this is <em>italic</em>.</p>
</blockquote>
<h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><ul>
<li><p>unordered list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* list 1</span><br><span class="line">* list 2</span><br><span class="line">* list 3</span><br><span class="line">* list 4</span><br></pre></td></tr></table></figure>
</li>
<li><p>list 1</p>
</li>
<li>list 2</li>
<li>list 3</li>
<li>list 4</li>
</ul>
<hr>
<ul>
<li>ordered list<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. list 1</span><br><span class="line">2. list 2</span><br><span class="line">3. list 3</span><br><span class="line">4. list 4</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>list 1</li>
<li>list 2</li>
<li>list 3</li>
<li>list 4</li>
</ol>
<hr>
<ul>
<li><p>nested list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* parent 1</span><br><span class="line"> * child 1</span><br><span class="line"> * child 2</span><br><span class="line">* parent 2</span><br><span class="line"> * child 1</span><br><span class="line"> * child 2</span><br><span class="line"> * child 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>parent 1</p>
<ul>
<li>child 1</li>
<li>child 2</li>
</ul>
</li>
<li>parent 2<ul>
<li>child 1</li>
<li>child 2</li>
<li>child 3</li>
<li>child’s child 1</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>nested list 에서도 indent를 맞추어 주고 싶을때는 다음과 같이 한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. this is for indent.</span><br><span class="line">same indent.</span><br><span class="line"></span><br><span class="line"> same indent 2.</span><br><span class="line"></span><br><span class="line">2. this is for number 2.</span><br><span class="line"></span><br><span class="line"> same indent.</span><br><span class="line"> &gt; do blockquotes.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>this is for indent.
same indent.</p>
<p>same indent 2.</p>
</li>
<li><p>this is for number 2.</p>
<p>same indent.</p>
<blockquote>
<p>do blockquotes.</p>
</blockquote>
</li>
</ol>
<h2 id="hr-수평선"><a href="#hr-수평선" class="headerlink" title="hr(수평선)"></a>hr(수평선)</h2><p>수평선은 다음과 같이 나타낸다.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line">***</span><br><span class="line">*****</span><br><span class="line">- - -</span><br></pre></td></tr></table></figure></p>
<hr>
<hr>
<hr>
<hr>
<h2 id="Paragraphs"><a href="#Paragraphs" class="headerlink" title="Paragraphs"></a>Paragraphs</h2><p>다음과 같은 문단을 작성한다고 해보자.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this is paragraph.</span><br><span class="line">this is sentence 1.</span><br><span class="line">this is sentence 2.</span><br></pre></td></tr></table></figure></p>
<p>하지만 이를 markdown으로 렌더링하면 줄바꿈이 되지 않고 다음과 같이 보인다.</p>
<p>this is paragraph.
this is sentence 1.
this is sentence 2.</p>
<p>줄바꿈을 하려면 여러가지 방법이 있는데 첫번째는 <em>hard break</em> 라고 불리는 방법을 사용하는 것이다.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this is paragraph.</span><br><span class="line"></span><br><span class="line">this is sentence 1.</span><br><span class="line"></span><br><span class="line">this is sentence 2.</span><br></pre></td></tr></table></figure></p>
<p>this is paragraph.</p>
<p>this is sentence 1.</p>
<p>this is sentence 2.</p>
<hr>
<p><em>soft break</em> 방식은 다음과 같다.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this is paragraph.··</span><br><span class="line">this is sentence 1.··</span><br><span class="line">this is sentence 2.··</span><br></pre></td></tr></table></figure></p>
<p>(여기서의 ·은 space를 의미한다.)<br>즉, 줄의 마지막에 space 2개를 붙여주면 된다.</p>
<p>this is paragraph.<br>this is sentence 1.<br>this is sentence 2.  </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-07T16:51:46.000Z" title="08/09/2020, 01:51:46">2020-09-08</time>&nbsp;게시 됨</span><span class="level-item"><a class="link-muted" href="/categories/OS/">OS</a></span><span class="level-item">20분안에 읽기 (약 2990 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/08/file-system-design/">파일시스템 5편 - 파일시스템 디자인-2</a></h1><div class="content"><p>이 글은 지난번 파일시스템 디자인-1 에 이은 글입니다.</p>
<h2 id="파일시스템-계층화"><a href="#파일시스템-계층화" class="headerlink" title="파일시스템 계층화"></a>파일시스템 계층화</h2><p>파일시스템은 계층화가 잘되어있다. 일반적으로 파일시스템은 여러 개의 layer로 나뉘어져 구성된다.  </p>
<p align="center">
    <img style="max-width:200px" alt="파일시스템 계층화" src="/images/filesystem/file-system-layering.png"/>
</p>

<p>위의 그림에서 각 layer를 간단하게 살펴보자.  </p>
<h4 id="Logical-file-system"><a href="#Logical-file-system" class="headerlink" title="Logical file system"></a>Logical file system</h4><p>여기서는 파일시스템의 메타데이터를 관리한다.  </p>
<h4 id="File-organization-module"><a href="#File-organization-module" class="headerlink" title="File-organization module"></a>File-organization module</h4><p>이 layer에서는 파일의 logical block 주소를 physical block 주소로 변환해준다. 예를들어 하드디스크를 매체로 사용하게되면 sector 주소로 접근해야 하는데 이를 위한 변환을 진행한다.  </p>
<h4 id="Basic-file-system"><a href="#Basic-file-system" class="headerlink" title="Basic file system"></a>Basic file system</h4><p>여기서는 위에서 변환된 physical block 주소를 가지고 읽고 쓰도록 command를 날린다. 여기서 DMA를 사용한다.  </p>
<h4 id="I-x2F-O-control"><a href="#I-x2F-O-control" class="headerlink" title="I&#x2F;O control"></a>I&#x2F;O control</h4><p>이는 device driver다. device driver가 하드웨어에 맞게 명령을 전달한다.  </p>
<br/>

<h2 id="Virtual-File-System"><a href="#Virtual-File-System" class="headerlink" title="Virtual File System"></a>Virtual File System</h2><p>파일시스템은 어쩔 수 없이 사용하는 매체에 의존성이 있다. 그래서 파일시스템은 종류가 여러가지가 있을 수 있다. 예를들어 요즘은 잘 안쓰지만 CD-ROM이 있을 수 있고 USB, SSD, Disk 그리고 파일이 현재 호스트가 아닌 다른 네트워크의 호스트에 있을 수도 있다.  Linux kernel 에서는 여러가지 파일시스템을 지원한다.<br>VFS는 다양한 logical file system 들을 추상화한다. 따라서 VFS를 통해 실제로 시스템에는 여러개의 다른 파일시스템이 사용되더라도 마치 1개의 파일시스템만 사용하는 것처럼 프로프래밍 할 수 있다. 이는 OOP의 개념과 같은데 특정 파일에 대해 read&#x2F;write syscall 이 호출되면 해당 파일이 속한 파일시스템 구현체의 read&#x2F;write 가 호출되는 방식이다.  </p>
<p align="center">
    <img style="max-width:500px" alt="VFS" src="/images/filesystem/vfs.png"/>
</p>

<br/>

<h2 id="File-System-data-structure"><a href="#File-System-data-structure" class="headerlink" title="File System data structure"></a>File System data structure</h2><p>파일시스템에서 사용하는 자료구조를 알아보면서 파일시스템에 대한 이해를 높여보자.<br>On-disk 그리고 In-memory 에서 사용하는 자료구조들을 볼 것이다.  </p>
<h4 id="On-disk-data-structure"><a href="#On-disk-data-structure" class="headerlink" title="On-disk data structure"></a>On-disk data structure</h4><p>On-disk 자료구조들은 이미 이전 포스트인 파일시스템 디자인-1 에서 vsfs(very simple file system)에서 살펴봤던 내용들이 많다.  </p>
<ul>
<li><strong>Boot block</strong><br>첫번째 block으로 운영체제가 booting 하기위해 필요한 정보를 담아놓는 block이다. 하지만 이를 안만드는 경우도 많다.  </li>
<li><strong>Super block</strong><br>파일시스템 관련 정보들이 어디에 저장되어있는지에 대한 metadata를 저장한다. 예를들어 inode table은 어디서 시작인지, data block은 어디 block부터 시작하는지, root directory에 대한 inode 번호 등을 저장한다. Super block은 보통은 각 disk partition의 첫번째 block 에 할당하고 이 super block 이 손상되면 파일시스템의 복구가 힘들기때문에 보통 중복해서 super block을 저장한다. 그리고 이 super block은 in-memory data structure로 메모리에 올려 캐싱한다.  </li>
<li><strong>File control block</strong><br>FCB(file control block)은 결국 inode와 같다. inode 자체도 disk에 저장이 필요하다.</li>
</ul>
<p>다음의 disk structure layout를 살펴보자.  </p>
<p align="center">
    <img style="max-width:300px" alt="On-disk data structure" src="/images/filesystem/disk-structure.png"/>
</p>

<p>여기서 각 inode table을 여러개로 나누어 저장한 이유는 data block과 inode가 가까우면 성능을 높일 수 있기때문에 조금씩 inode 들을 나누어 설계했다. 다만 이런 내용들은 전적으로 파일시스템 구현에 달라진다.<br>결국 여기서의 그림을 보면 파일 접근을 위해서 super block, inode, data block 에 대한 접근으로 파일 하나의 접근에 대해 3번의 disk access가 필요하다.  </p>
<br/>

<h4 id="In-memory-data-structure"><a href="#In-memory-data-structure" class="headerlink" title="In-memory data structure"></a>In-memory data structure</h4><p>보통 파일시스템에서의 in-memory data structure 들은 거의 caching을 통한 성능향상 그리고 파일시스템 관리가 목표이다.  </p>
<ul>
<li><strong>Dentry</strong><br>이는 directory cache 이다. directory 접근을 위해 on-disk 의 super block 그리고 root directory 의 inode 부터 접근해서 dentry 라는 directory cache를 만든다. dentry로 파일접근시 해당 파일의 inode를 알기위해 여러번 disk 에 접근할 필요가 없이 memory 에서 처리할 수 있다.  </li>
<li><strong>open file table</strong><br>이는 예전에 살펴본 내용으로 system-wide open file table 그리고 per process open file table 이 있는데 각각 open 한 file을 관리한다. per-process open file table 에서 각 index 번호가 file descriptor 가 된다.  </li>
<li><strong>Buffer cache</strong><br>최근에 사용한 data block 을 memory 에 캐싱한다.</li>
</ul>
<br/>

<h2 id="Buffer-Cache"><a href="#Buffer-Cache" class="headerlink" title="Buffer Cache"></a>Buffer Cache</h2><p>Buffer cache는 조금 더 자세히 살펴보겠다.<br>Buffer cache는 파일의 메타데이터가 아닌 data block 자체를 메모리에 올려둔다. 보통 같은 data block을 다시 접근해야 하는 경우가 많기때문에 이를 캐싱해두면 다시 disk를 조회하지 않아도된다.<br>다만 buffer cache는 완전한 software로 구현된다. 이 말은 virtual memory의 주소변환을 위해 TLB 같은 하드웨어를 도입하는게 아닌 순수한 software 레벨에서 구현한 캐시라는 의미이다.<br>Buffer cache는 보통 물리메모리의 1 ~ 10% 정도로 할당하고 이는 kernel parameter로 수정이 가능하다. Buffer cache 도 공간이 한정되므로 교체알고리즘을 사용한다. 보통 disk access 에는 locality가 나타나기 때문에 LRU 방식을 사용한다.<br>다만 DBMS 나 multimedia application은 LRU 로 이득을 볼 수 없는 경우가 대부분이기 때문에 이들은 buffer cache를 거치지 않고 바로 disk 에 접근할 수 있는 flag를 사용해서 buffer cache를 거치지 않도록 프로그래밍 한다.  </p>
<p>Read syscall 과 Write syscall 각각의 동작방식을 buffer cache 의 관점에서 살펴보자.  </p>
<h4 id="Read-syscall"><a href="#Read-syscall" class="headerlink" title="Read syscall"></a>Read syscall</h4><p align="center">
    <img style="max-width:600px" alt="Buffer cache read" src="/images/filesystem/buffer-cache-read.png"/>
</p>

<p>먼저 <code>read(fd, buf, size)</code> syscall 을 호출한다. <code>read</code> syscall 의 두번째 인자인 buf 는 사용자의 buffer를 의미한다.<br>그다음 VFS에서는 file descriptor를 보고 file이 있는 device를 알아낸 후 logical block number 를 physical block number 로 변환한다. buffer cache 쪽에 해당 block이 있는지 확인을 하고 block 이 없다면 파일시스템에서 가져와야한다. 만약 buffer cache에 이미 cache된 block이 있으면 VFS에 반환한다.<br>cache된 block이 없다면 파일시스템에 block을 요청하고 이 <code>read</code> 를 요청한 프로세스는 sleep 한다. 즉, context switching 이 일어난다. I&#x2F;O가 필요하기 때문이다. 나중에 disk에서 block을 읽어오면 interrupt 가 발생하고 그 block 을 다시 caching 해주고 block 을 반환한다.<br>VFS에 반환할때는 application의 buf에 block들을 copy해주고 읽어온 byte 수를 반환한다.  </p>
<p>만약 <code>read</code> 를 하더라도 buffer cache 에 대상 block 이 존재하여 cache hit 이 된다면, 해당 프로세스는 sleep 하지 않는다.<br>그리고 buffer cache 쪽을 보게되면 hash table 구조로 구현되어 있고 value로는 linked list 로 각 cache 되어있는 data block 들이 있는 것을 확인할 수 있다. hash 의 key로는 보통은 block number 를 사용한다고 한다.</p>
<br/>

<h4 id="Write-syscall"><a href="#Write-syscall" class="headerlink" title="Write syscall"></a>Write syscall</h4><p align="center">
    <img style="max-width:600px" alt="Buffer cache write" src="/images/filesystem/buffer-cache-write.png"/>
</p>

<p>먼저 <code>write(fd, buf, size)</code> syscall 을 호출한다.<br>VFS에서 device 및 block number로 변환하여 buffer cache에 해당 block이 이미 있는지 확인한다. 만약 write 하려는 block 이 buffer cache에 없다면 먼저 파일시스템에서 읽어오도록 요청한다. 이 과정에서도 <code>write</code>를 요청한 프로세스는 sleep 한다.<br>파일시스템에서 읽어왔으면 다시 write를 시도하면 해당 block이 buffer cache 에 존재하므로 이 경우에는 해당 buffer cache의 data block에 직접 write를 수행하고(in-memory) 해당 block이 disk에 있는 block과 일치하지 않는다는 표시를 하기위해 dirty bit를 체크한다.<br>만약 처음부터 buffer cache에 write 시도시 해당 block 이 buffer cache에 있었다면 바로 그 block에 write 하고 반환한다.  </p>
<p>이런 방식이면 buffer cache와 disk 의 sync가 깨지게 되는데 이는 다른 worker 스레드가 주기적으로 dirty bit가 체크된 data block 들을 disk에 sync 시켜준다.  </p>
<h4 id="kworker"><a href="#kworker" class="headerlink" title="kworker"></a>kworker</h4><p>이 kworker 라는 kernel thread가 buffer cache와 disk block 간의 동기화를 수행한다.<br>예를들어 data block은 30초, metadata는 5초마다 동기화를 시킬수도 있다. 다만 이런 구현은 실제 OS 구현마다 다르며 파일시스템 구현마다도 다르다.<br>다만 이런 방식이면 순간적으로 머신이 꺼지거나 할때 동기화가 되지 않은 부분은 유실될 수 있다. 즉 write를 하더라도 그 내용이 disk에 반영된다는 보장이 없다. 이를 위해 저널링 파일시스템 같은 대안을 사용한다.<br>Application 에서 <code>fsync</code> system call을 사용하면 강제적으로 buffer cache의 내용을 disk에 반영한다.<br>DBMS도 구현마다 다르지만 매번의 update 마다 fsync 를 수행하지는 않는다. DBMS에서는 이를 write ahead log 과 transaction을 이용해 해결한다.  </p>
<br/>

<h2 id="Memory-Mapped-File-mmap"><a href="#Memory-Mapped-File-mmap" class="headerlink" title="Memory-Mapped File(mmap)"></a>Memory-Mapped File(mmap)</h2><p>mmap은 파일을 프로세스의 address space 한 부분으로 mapping 한다. 파일을 프로세스의 memory space 에 그냥 가져다가 붙힌다고 생각하면 쉽다.<br>이렇게 되면 단순히 memory access instruction 을 통해 파일에 대한 read, write을 할 수 있다. kernel은 이런 memory access instruction 을 적절하게 read, write로 변환하여 수행해준다.<br>mmap 함수는 다음과 같다.  </p>
<p><code>void* mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset)</code></p>
<p><code>start</code>는 단지 이 주소를 사용했으면 좋겠다는 의미로 0을 보통 넣는다. 그리고 <code>offset</code> 부터의  <code>length</code> 만큼의 바이트를 <code>start</code> 주소로 매핑하기를 원한다는 의미이다.<br><code>fd</code>는 파일에 대한 file descriptor 로 이미 존재하는 파일에 대한 file descriptor 를 넘겨 이를 읽거나 수정할 수도 있고, 새로운 파일을 <code>O_CREAT</code> flag 와 함께 open 하여 이 file descriptor 를 넘겨 새로운 파일을 쓸 수도 있다.  </p>
<p>유저는 파일에 대한 I&#x2F;O 를 단지 <code>memset</code>, <code>memcpy</code> 같은 memory access 로 단순화 할 수 있다.<br>그리고 여러개의 프로세스에서 동일한 파일을 open 하여 사용할 경우 kernel 은 동일한 파일에 대한 내용을 memory에 1개만 들고있으면 된다.  </p>
<p>mmap 파일의 동작을 그림으로 보자.  </p>
<p align="center">
    <img style="max-width:600px" alt="mmap 과정" src="/images/filesystem/mmap.png"/>
</p>

<p>먼저 mmap 을 사용하지 않는 경우를 생각해보면, disk 에서 DMA로 data block을 가져오면 이를 buffer cache에 올리고 그다음 사용자 buffer 로 copy를 해야한다.<br>buffer cache 로는 DMA 가 copy 해주지만, buffer cache 에서 user buffer 로는 CPU가 직접 copy 해야한다. 따라서 file IO 가 빨라지려면 CPU도 중요하다.  </p>
<p>mmap은 조금 다르다. mmap은 buffer cache를 사용하지 않는다. mmap은 buffer cache에 data block을 쓰지 않고 바로 kernel space로 DMA가 쓴다. 그리고 이를 프로세스의 address space 에 page table을 통해 매핑한다.<br>따라서 user buffer 로의 copy가 존재하지 않는다.<br>위의 그림에서는 process A 와 process B 가 각각 mmap 되어있는 physical fragment 를 공유하고 있다. mmap 에서는 flag에 <code>MAP_SHARED</code> flag 를 통해 다른 프로세스와 mmap 된 파일을 공유할 수 있다. 하지만 다른 동기화 같은 장치는 제공하지 않는다.<br>process A 에서 먼저 특정 파일을 mmap 하였을때 그 다음 process B 에서 같은 파일에 대해 mmap을 하게되면 서로 반환받는 virtual address 주소는 다르지만, 결국 page table 에 매핑된 physical address 주소는 같아 같은 파일을 바라보게 된다.  </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-07T15:51:46.000Z" title="08/09/2020, 00:51:46">2020-09-08</time>&nbsp;게시 됨</span><span class="level-item"><a class="link-muted" href="/categories/OS/">OS</a></span><span class="level-item">31분안에 읽기 (약 4638 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/08/file-system-design-1/">파일시스템 4편 - 파일시스템 디자인-1</a></h1><div class="content"><p>이 글은 학부 System Programming 수업을 듣고 파일시스템 관련내용을 정리한 글입니다.  </p>
<p>이번 편에서는 크게 다음 2가지를 볼 것이다.  </p>
<ol>
<li>File System의 디자인</li>
<li>Directory의 디자인</li>
</ol>
<p>unix 시스템에서 파일과 디렉토리는 비슷하면서도 다르게 구현이된다.<br>파일의 디자인부터 살펴보자.  </p></div><a class="article-more button is-small is-size-7" href="/2020/09/08/file-system-design-1/#more">자세히 보기</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-07T07:14:20.000Z" title="07/09/2020, 16:14:20">2020-09-07</time>&nbsp;게시 됨</span><span class="level-item"><a class="link-muted" href="/categories/OS/">OS</a></span><span class="level-item">40분안에 읽기 (약 6049 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/07/file-system-concept/">파일시스템 3편 - 파일시스템이란?</a></h1><div class="content"><p>이 글은 학부 System Programming 수업을 듣고 파일시스템 관련내용을 정리한 글입니다.  </p>
<h2 id="파일-File-이란"><a href="#파일-File-이란" class="headerlink" title="파일(File)이란?"></a>파일(File)이란?</h2><p>파일은 무엇일까?<br>파일은 <strong>linear array of bytes</strong> 이다. 이게 무슨말일까?<br>이전 운영체제 메모리편에서 보았듯이 address space는 sparse 하다. 즉 프로세스가 사용하는 주소공간은 중간부분을 사용하지 않고 비어있을 수 있다. 그러므로 효율적으로 사용하고자 multi-level page table을 사용하곤 했었다.<br>이와 다르게 파일은 linear array of bytes로 중간이 비어있지 않다. 그리고 파일은 byte addressable하다. Byte 단위로 접근이 가능하다는 것이다. 그리고 여기서의 linear array는 밑에서 보겠지만 logical한 block이 linear하다는 것이다.  </p></div><a class="article-more button is-small is-size-7" href="/2020/09/07/file-system-concept/#more">자세히 보기</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-05T16:51:46.000Z" title="06/09/2020, 01:51:46">2020-09-06</time>&nbsp;게시 됨</span><span class="level-item"><a class="link-muted" href="/categories/OS/">OS</a></span><span class="level-item">44분안에 읽기 (약 6653 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/06/file-system-flash/">파일시스템 2편 - Flash 그리고 SSD</a></h1><div class="content"><p>이 글은 학부 System Programming 수업을 듣고 다른 자료들과 함께 공부한 내용을 정리한 글입니다.<br>이전 포스트의 하드디스크에 이어 이번 포스트에서는 Flash 그리고 SSD에 대해 알아볼 것입니다.  </p>
<p>이번 편은 이전의 <a href="/2019/07/09/os-computer-architecture/">운영체제 3편 - 컴퓨터 구조와 I&#x2F;O</a> 글의 I&#x2F;O 부분을 이해하고보면 도움이 됩니다.  </p>
<br/>

<h2 id="Flash-Memory"><a href="#Flash-Memory" class="headerlink" title="Flash Memory"></a>Flash Memory</h2><p>하드디스크와 다르게 Flash는 메모리나 CPU처럼 트랜지스터 들로 구성이 되어있다. 즉 disk의 arm이 움직이거나 platter가 회전하는 물리적인 움직임이 없다.<br>Reliability 측면에서도 disk에 비해 훌륭한 편이다. Disk는 물리적인 head crash가 날수도 있고, dead block(더이상 사용할 수 없는 block) 자체가 생길 수 있다. 물리적으로 읽고 쓰기 때문이다. 그리고 disk는 생각보다 자주깨진다.<br>이와는 다르게 Flash는 순수한 silicon으로 구성되어 있으며 전자적으로 동작하기에 더 신뢰성이 높다. Flash는 또한 매우 빠른 access time을 제공하고 power가 적게드는 반도체 특성으로 disk에 비해 매우매우 저전력이다. Flash Memory는 여러타입이 있는데 보통은 NAND-Flash를 의미한다. 
다만 Flash가 가진 특이한 특성들 때문에 이를 해결하기 위해 몇가지 기법들을 적용해야한다. 이들은 밑에서 자세히 알아볼 것이다.   </p>
<p>Flash chip은 하나의 transistor의 1개 이상의 bit를 저장할 수 있다. <strong>SLC(Single-Level Cell)</strong> flash는 오직 1개의 bit만 transistor에 저장할 수 있고, <strong>MLC(Multi-Level Cell)</strong> flash는 2개의 bit를 저장할 수 있다. 그러므로 00, 01, 10, 11을 저장할 수 있다. <strong>TLC(Triple-Level Cell)</strong> flash는 3개의 bit를 저장가능하다. 전반적으로 SLC가 더 성능이 좋고 가격이 비싸다.  </p></div><a class="article-more button is-small is-size-7" href="/2020/09/06/file-system-flash/#more">자세히 보기</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-04T15:51:46.000Z" title="05/09/2020, 00:51:46">2020-09-05</time>&nbsp;게시 됨</span><span class="level-item"><a class="link-muted" href="/categories/OS/">OS</a></span><span class="level-item">25분안에 읽기 (약 3718 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/05/file-system-hard-disk/">파일시스템 1편 - 하드디스크</a></h1><div class="content"><p>이 글은 학부 System Programming 수업을 듣고 다른 자료들과 함께 공부한 내용을 정리한 글입니다.  </p>
<p>처음으로 파일시스템 자체를 보기전에 물리적인 device의 작동원리에 대해 이해를 하고 파일시스템을 보게되면 더 이해가 쉽습니다. 이번 편에서는 하드디스크에 대해 다룰 것입니다.  </p>
<p>이번 편은 이전의 <a href="/2019/07/09/os-computer-architecture/">운영체제 3편 - 컴퓨터 구조와 I&#x2F;O</a> 글의 I&#x2F;O 부분을 이해하고보면 도움이 됩니다.  </p></div><a class="article-more button is-small is-size-7" href="/2020/09/05/file-system-hard-disk/#more">자세히 보기</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-04T15:51:46.000Z" title="05/09/2020, 00:51:46">2020-09-05</time>&nbsp;게시 됨</span><span class="level-item"><a class="link-muted" href="/categories/OS/">OS</a></span><span class="level-item">27분안에 읽기 (약 4115 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/05/raid/">파일시스템 2편 - RAID</a></h1><div class="content"><p>이 글은 학부 System Programming 수업을 듣고 다른 자료들과 함께 공부한 내용을 정리한 글입니다.<br>이전 포스트의 하드디스크에 이어 이번 포스트에서는 RAID에 대해 알아볼 것입니다.  </p>
<p>이번 편은 이전의 <a href="/2019/07/09/os-computer-architecture/">운영체제 3편 - 컴퓨터 구조와 I&#x2F;O</a> 글의 I&#x2F;O 부분을 이해하고보면 도움이 됩니다.  </p>
<br/>

<h2 id="What-is-RAID"><a href="#What-is-RAID" class="headerlink" title="What is RAID?"></a>What is RAID?</h2><p><strong>RAID</strong>는 <strong>Redundant Array of Inexpensive Disks</strong>의 약자이다. 즉 여러개의 disk를 사용해서 더 빠르고, 더 크고, 더 신뢰성 있는 disk 시스템을 구축하는 방식이다.<br>외부적으로 보는 관점에서는 RAID는 그냥 disk와 동일하다. 외부에서는 그저 큰 disk처럼 바라볼 뿐이다. disk와 동일하게 block의 묶음을 읽고 쓸수있다. 하지만 RAID 내부적으로는 시스템을 관리하는 프로세서도 존재하고 메모리도 존재하며 무엇보다 여러개의 disk로 구성되어 있다. </p>
<p>RAID는 왜 쓰는 것일까?<br>RAID를 사용하면 먼저 성능상으로 이득을 볼 수 있다. 여러개의 disk에 병렬로 I&#x2F;O를 할 수 있다. 그리고 용량(capacity)측면에서도 이득을 볼 수 있다. 한개의 disk 크기를 넘어서는 크기를 저장할 수 있기 때문이다.<br>그리고 신뢰성(reliability)도 더 높은데 RAID를 구성하는 방식에 따라 다를 수 있지만 데이터를 여러 disk에 중복해서 저장함으로서 single disk failure에 대해 극복할 수 있고 외부에서는 single disk failure가 일어나도 아무 일도 일어나지 않은 것처럼 수행할 수 있다.  </p>
<br/>

<h2 id="RAID-Internals"><a href="#RAID-Internals" class="headerlink" title="RAID Internals"></a>RAID Internals</h2><p>파일시스템 밑에서 RAID는 그저 매우 크고 신뢰성있고 빠른 disk 처럼 보일뿐이다. single disk처럼 linear array of blocks로 보이고 각 block은 파일시스템에 의해 읽고 쓰여질 수 있다.<br>파일시스템이 RAID에 logical block에 대해 I&#x2F;O 요청을 하면 RAID는 내부적으로 여러 disk를 가지고 있는데 어떤 disk에 접근해서 physical I&#x2F;O를 할 지 결정하고, 수행한 후 그 결과를 반환한다. 이 physical I&#x2F;O를 어떻게 수행할 것인가는 밑에서 볼 RAID level에 따라 다르다.<br>간단하게 RAID가 각 disk의 copy본을 들고있는 mirrored RAID 라고 해보자. 그러면 write을 수행할 때 각 block들을 disk에 2번씩 써주어야 한다.  </p>
<br/>

<h2 id="RAID-Evaluation"><a href="#RAID-Evaluation" class="headerlink" title="RAID Evaluation"></a>RAID Evaluation</h2><p>RAID를 구성하는 방법은 여러가지가 있다. 구성하는 방법에 따라 특징 그리고 장단점이 존재하는데 이런 특징을 수치로 측정할 수 있으로면 비교하기 쉽다. 그래서 우리는 3가지 측면에서 RAID의 특징을 측정할 것이다.  </p>
<h4 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h4><p>먼저 capacity이다. <code>B</code>개의 block을 저장할 수 있는 <code>N</code>개의 disk가 있다. 클라이언트는 RAID에 얼마나 많은 용량을 저장할 수 있을까?<br>중복없이 저장한다면 <code>N * B</code>가 되겠다. 각 block마다 copy본을 둔다면 <code>N * B / 2</code>가 되겠다.  </p>
<h4 id="reliability"><a href="#reliability" class="headerlink" title="reliability"></a>reliability</h4><p>두번째는 reliability 즉 신뢰성이다. RAID가 몇개의 disk failure 까지 허용할 수 있을까에 대해 이야기한다.  </p>
<h4 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h4><p>마지막은 performance이다. Performance는 측정하기 조금 힘들 수 있는데 RAID에 요청되는 작업의 종류에 의존하는 경우가 많기 때문이다.<br>RAID performance를 측정할때는 크게 2가지 측면을 고려할 것인데 첫번째는 <strong>single-request latency</strong>이다. RAID에서 single I&#x2F;O 요청에 대해 어떤 latency를 가지는지를 측명하면 얼마나 해당 RAID가 병렬성을 가지고 있는지 그대로 이해할 수 있다.<br>두번째는 <strong>steady-state throughput</strong> 이다. 어떤 규칙적인 요청이 왔을때 그때의 처리량을 의미한다. 예를들어 여러개의 요청이 동시에 왔을때 그때의 RAID 전체의 bandwidth를 측정할 수 있겠다.<br>이들을 조금 더 자세히 측정하기 위해 각 요청에 대한 내용들이 두가지 종류가 있다고 가정한다. <strong>sequential</strong>과 <strong>random</strong>이다.<br>sequential workload는 요청들이 큰 단위의 연속된 block을 읽는 요청들로 이루어져 있다고 가정한다. 이런 sequential workload는 큰 파일을 읽어 특정 키워드를 찾고싶을때처럼 자주 오는 요청들이다.<br>random workload는 각 요청은 매우 작은 크기의 block을 읽는 요청들이고 각 요청들은 서로 다른 disk location을 대상으로 한다. 예를들어 처음 4KB에 대해 logical address 10에 접근하고 그다음은 logical address 55,000 그 다음은 logical address 4,500 에 접근하는 방식이다. 이런 random workload는 database에서 빈번하게 일어난다.  </p>
<p>위의 sequential, random workload는 disk의 특성으로 인해 각각 다른 performance 특징을 가진다.<br>sequential access에서는 disk는 가장 효율적인 방식으로 동작한다. seek time과 rotational delay에 매우 적은 시간을 사용하므로 대부분의 시간을 data transfer에 활용할 수 있다.<br>다만 random access의 경우는 대부분의 시간을 seek time과 rotational delay에 사용하므로 상대적으로 data transfer에는 작은 시간을 할애할 수밖에 없다.<br>그래서 이런 차이점을 더 명확히 확인하기 위해 sequential workload 에서는 <code>S MB/s</code> 로 data transfer가 가능하다고 하고, random workload 에서는 <code>R MB/s</code> 속도로 data transfer가 가능하다고 하자. 보통은 S가 R보다 훨씬 크다. 이 측정치를 밑에서 RAID level 별로 계산해보며 성능을 비교해볼 것이다.  </p>
<p>밑에서는 몇가지 RAID 종류들을 보게될 것이다. <strong>RAID Level 0</strong>(striping), <strong>RAID Level 1</strong>(leveling), <strong>RAID Levels 4, 5</strong>(parity-based redundancy)이다.  </p>
<br/>

<h2 id="RAID-Level-0-Striping"><a href="#RAID-Level-0-Striping" class="headerlink" title="RAID Level 0: Striping"></a>RAID Level 0: Striping</h2><p>RAID 0은 <strong>striping</strong>으로 더 잘 알려져 있다. 이 방식은 capacity와 performance 측면에서 높은 결과를 낸다.<br>striping은 말그대로 줄무늬 방식이라고 이해해도 좋다. striping 방식에서는 각 block들을 여러 disk에 걸쳐 줄무늬처럼 배열한다. 다음 그림을 보자.  </p>
<p align="center">
    <img alt="RAID 0: Striping" style="max-width: 350px;" src="/images/filesystem/raid-0.png"/>
</p>
  
<p>여기서는 4개의 disk를 사용했다. striping의 기본 아이디어는 block의 array를 라운드로빈 방식으로 disk에 하나씩 할당한다. 이 방식은 large sequential read 요청에 대해 병렬로 처리할 수 있도록 설계한 방식이다.<br>위의 예에서는 1개의 block(4KB) 기준으로 라운드로빈으로 disk에 할당하였는데 다음과 같이 할당할수도 있다.  </p>
<p align="center">
    <img alt="RAID 0: Bigger chunk size" style="max-width: 400px;" src="/images/filesystem/raid-0-bigger.png"/>
</p>

<p>여기서는 다음 disk로 넘어가기 전에 2개의 block(8KB)를 할당하고 다음 disk로 넘어갔다. 이 단위를 <strong>chunk size</strong>라고 한다. 여기서는 8KB의 chunk size를 사용하였다. </p>
<h4 id="Chunk-Size"><a href="#Chunk-Size" class="headerlink" title="Chunk Size"></a>Chunk Size</h4><p>chunk size는 performance에 영향을 많이 끼친다. 작은 chunk size를 사용한다면 많은 파일들이 여러 disk에 striped 되어 저장될 것이다. 그러므로 파일 read write 시에 병렬성을 증가시킬 수 있을것이다.<br>다만 block에 접근하기 위한 positioning time(seek time + rotational delay)가 증가한다. 왜냐하면 여러 disk에 병렬로 읽거나 쓰게될때 결국 완료시간은 가장 오랜시간이 걸린 positioning time에 의해 결정되기 때문이다.  </p>
<p>chunk size를 크게잡으면 어떨까?<br>작은 크기의 파일에 대해선은 read, write에 병렬성은 떨어질 것이다. 그러나 positioning time이 줄어들 것이다. 만약 작은 크기의 파일의 크기가 chunk size보다 작아 single disk에 저장된다면 그 single disk 에서의 positioning time이 결정한다.  </p>
<p>그러므로 최적의 chunk size를 찾기 위해서는 어떤 요청들을 위주로 처리할지에 대한 지식이 먼저 있으면 결정하기 좋다.<br>대부분은 큰 chunk size(64KB)를 사용하고는 한다.  </p>
<h4 id="RAID-0-Evaluation"><a href="#RAID-0-Evaluation" class="headerlink" title="RAID 0 Evaluation"></a>RAID 0 Evaluation</h4><p>RAID 0 에서 capacity, reliability, performance를 측정해보자.<br>먼저 capacity는 간단하다. <code>B</code>개의 block들로 이루어진 <code>N</code>개의 disk가 있다면 <code>N * B</code>의 block을 저장할 수 있다.<br>reliability도 간단한데 striping 방식에서는 reliability가 좋지 않다. 하나의 disk가 fail이 나더라도 바로 data loss로 이어진다.   </p>
<p>performance는 위에서 본 sequential workload의 <code>S</code>와 random workload의 <code>R</code>을 구해보며 비교해보자.<br>sequential transfer size는 평균적으로 10MB, random transfer size는 평균적으로 10KB라고 가정하자. 이들을 전송하는데 속도가 얼마인지 계산해보자.<br>Disk의 spec은 다음과 같다.  </p>
<ul>
<li>Average seek time: 7ms</li>
<li>Average rotational delay: 3ms</li>
<li>Transfer rate of disk: 50MB&#x2F;s</li>
</ul>
<p><code>S</code>는 <code>(Amound of Data) / (Time to access)</code> 이므로 <code>10MB / (7ms + 3ms + 200ms) = 47.62 MB/s</code> 와 같다. Time to access는 seek time + rotational delay와 10MB를 전송하는데 200ms가 걸리므로 이를 합치면 계산할 수 있다.<br><code>R</code>은 <code>10KB / 10.195ms = 0.981 MB/s</code>이다. 10KB를 전송하는데 0.195ms가 걸린다.<br>이 <code>S</code>와 <code>R</code>은 disk 1개에서 고려한 속도이다.  </p>
<p>이처럼 striping의 performace를 보게되면 single-block request에 대해서는 single disk 성능과 동일하다.<br>하지만 sequential, random workload 관점에서 볼때 sequential workload는 하나의 disk가 <code>S</code>의 속도를 낼때 <code>N</code>개의 disk가 있다면 전체 처리량은 <code>S * N</code>이 되겠다.<br>randon workload 에서의 전체 처리량은 <code>R * N</code>이 된다. </p>
<br/>

<h2 id="RAID-Level-1-Mirroring"><a href="#RAID-Level-1-Mirroring" class="headerlink" title="RAID Level 1: Mirroring"></a>RAID Level 1: Mirroring</h2><p>RAID Level 1은 <strong>mirroring</strong>으로 잘 알려져있다. Mirrored System에서는 각 block에 대해 copy본을 같이 저장함으로서 disk failure를 극복할 수 있다. 전형적인 mirroring 방식은 다음과 같다.  </p>
<p align="center">
    <img alt="RAID 1: Mirroring" style="max-width: 350px;" src="/images/filesystem/raid-1.png"/>
</p>

<p>위의 방식에서는 RAID는 물리적으로 두개의 물리적 copy를 저장한다. disk 0은 disk 1과 동일한 내용을 들고있고 disk 2는 disk 3과 동일한 내용을 들고있다. 데이터들은 이 mirror pair들에 걸쳐 striped 된다.<br>disk들에 copy본들을 어디에 위치시킬지는 여러가지 방법이 있는데 위에서 본 방식은 가장 일반적인 방식으로 이런 방식을 <code>RAID-10</code>이라고 부르기도 한다. <strong>stripe of mirror</strong>로 RAID1+0 라는 의미이다.  </p>
<p>disk read를 할때는 복제본 disk 두개중 어디에서 읽어도 상관없다. 다만 write은 두개의 disk에 모두 써주어야 한다. 이 2번의 write은 병렬로 처리할 수 있다.<br>또 위의 경우 복제본을 2개 저장했는데 이를 <strong>mirroring level</strong>이라고도 한다. 여기서는 mirroring level이 2이다.  </p>
<h4 id="RAID-1-Evaluation"><a href="#RAID-1-Evaluation" class="headerlink" title="RAID 1 Evaluation"></a>RAID 1 Evaluation</h4><p>RAID 1 에서 capacity를 먼저보자. capacity 관점에서 RAID 1은 비용이 비싸다. mirroring level 2 에서는 전체 용량의 절반만 저장할 수 있으므로 capacity는 <code>N * B / 2</code>가 되겠다.  </p>
<p>reliability의 관점에서는 좋다. 아무 disk 1개의 failure를 허용할 수 있다. 사실 정확히는 최대 <code>N/2</code>개의 disk failure 까지 허용가능하다. 위에서 본 예제에서도 만약 운이 좋게도 disk 0과 disk 2가 동시에 fail 했다고 하더라도 data loss가 발생하지 않는다. 운이 좋게 각 copy 본을 저장하는 disk가 중복없이 fail이 발생했기 때문이다.  </p>
<p>performance 관점을 살펴보자. single read request는 single disk와 성능이 동일하다.<br>다만 single write request는 살짝 더 latency가 늘어날 수 있는데, 각 copy 본을 병렬로 write한다고 하더라도 완료되는 시점은 두개의 disk중 더 오래걸린 시간이기 때문이다.  </p>
<p>steady-state throughput을 살펴보자. 
sequential write에서는 각 logical write은 두개의 physical write으로 나누어진다. 그러므로 mirroring 방식에서 전체 bandwidth는 <code>(N / 2) * S</code>가 된다. 최대 bandwidth의 절반밖에 안된다.<br>sequential read도 똑같은데 얼핏 생각하면 각 logical read를 모든 disk에 나누어 처리하면 상황이 더 나아질 것 같지만 disk의 물리적 특성을 생각하면 그렇지 않다. 예를들어 위의 그림에서 block 0 부터 7까지 읽는다고 했을때 block 0은 disk 0에서, block 1은 disk 2에서, block 2는 disk 1에서 block 3은 disk 3에서 읽는다고 해보자. disk 0에서는 block 0을 읽고 그다음 block 4를 읽으면 될 것 같지만 어차피 중간에 block 2가 존재하기 때문에 rotation 하면서 이를 지나가야한다. 그러므로 성능향상이 없다. 그러므로 sequential read 에서의 전체 bandwidth도 <code>N / 2) * S</code>와 같다.  </p>
<p>Random read는 mirroring 방식에서 best case이다. read를 전체 disk에 분산시킬 수 있으므로 <code>N * R MB/s</code>의 대역폭을 가진다.<br>Random write은 sequential write과 동일하게 두개의 physical write로 나누어지므로 <code>(N / 2) * R MB/s</code> 이다.  </p>
<br/>

<h2 id="RAID-Level-5-Rotating-Parity"><a href="#RAID-Level-5-Rotating-Parity" class="headerlink" title="RAID Level 5: Rotating Parity"></a>RAID Level 5: Rotating Parity</h2><p>RAID Level 5에서는 parity 정보를 활용한다.<br>Parity bit은 오류가 생겼는지 검사하는 bit 인데 2가지 종류가 존재한다. 짝수 parity와 홀수 parity이다.<br>개념은 간단한데 짝수 parity에서는 데이터의 각 bit의 값에서 parity bit를 포함한 1의 개수가 짝수가 되도록 하는 것이다. 홀수 parity는 홀수가 되도록 하는것이다. 예를들어 다음과 같다.  </p>
<p align="center">
    <img style="max-width: 350px;" src="/images/filesystem/parity.png"/>
</p>

<p>짝수 parity라면 C0, C1, C2, C3의 bit에서 1의 개수가 2개이므로 parity bit을 0으로 둔다. 그래야 짝수인 2개로 유지되기 때문이다. parity bit을 활용하면 C0, C1, C2, C3 중 한개가 유실되어도 그 값을 bit 계산으로 알아낼 수 있다.  </p>
<p>다시 RAID로 돌아와서 RAID Level 5 방식을 그림으로 보자.  </p>
<p align="center">
    <img alt="RAID 5: Rotating Parity" style="max-width: 400px;" src="/images/filesystem/raid-5.png"/>
</p>
  
<p>여기서는 parity bit을 disk 별로 돌아가며 설정한다. 즉 위의 block 0, 1, 2, 3의 각 block의 bit를 계산해서 그에 대한 parity bit을 disk 4에 저장한다.  </p>
<h4 id="RAID-5-Evalutation"><a href="#RAID-5-Evalutation" class="headerlink" title="RAID 5 Evalutation"></a>RAID 5 Evalutation</h4><p>capacity 부터 확인해보자. stripe 당 1개의 parity block을 두기때문에 <code>(N - 1) * B</code>의 용량을 가지게 된다.<br>reliability 는 1개의 disk failure를 허용한다. parity bit를 활용해 recovery 가능하다. 다만 2개이상의 disk failure가 나면 복구할 방법이 없다.<br>그렇다면 performance를 계산해보자.<br>single read request는 1개의 disk로 매핑되기 때문에 single disk와 성능이 동일하다.<br>다만 single write request는 다른데 위 예제에서 block 0에 write을 하려면 block 0을 읽고 parity block도 읽어서 parity bit를 다시 계산해야한다. 즉 read 2번, write 2번이 필요하고 read, write 각각 병렬로 처리할 수 있으므로 single disk의 latency의 약 2배정도 걸린다.  </p>
<p>sequential read는 parity block으로 인해 <code>(N - 1) * S MB/s</code>의 대역폭을 가진다. sequential write도 parity bit을 같이 써주어야 하므로 <code>(N - 1) * S MB/s</code>가 되겠다.<br>random read는 모든 disk를 활용할 수 있다. 다만 random write은 <code>(N / 4) * R MB/s</code>을 가진다.<br>왜냐하면 만약 random write가 위 예제에서 block 1과 block 10에 대해 요청이 왔다면 parity bit 계산을 위해 disk 1과 disk 4를 읽어 block 1을 처리하고, disk 0과 disk 2를 읽어 block 10을 처리한다. 각 요청안에서 block data write과 parity block write은 병렬로 처리할 수 있므으로 총 4개의 I&#x2F;O 가 필요하다.(disk 1의 read&#x2F;write + disk 0의 read&#x2F;write)  </p>
<p>RAID Level 별로의 evaluation 결과는 다음과 같다.  </p>
<p align="center">
    <img alt="RAID Evaluation" style="max-width: 700px;" src="/images/filesystem/raid-evaluation.png"/>
</p>

<br/>

<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>reliability는 고려하지 않고 performance가 중요한 상황이라면 RAID 0 striping이 좋은 선택이 될 수 있다.<br>반대로 reliability가 중요하고 random I&#x2F;O 성능이 중요하다면 RAID 1 mirroring이 좋은 선택이다. 다만 비용이 비싸다.<br>capacity와 reliability가 중요하다면 RAID 5 가 좋은 선택이다. 다만 small-write의 성능이 좋지않은면이 있다.<br>만약 sequential I&#x2F;O가 주된 접근이고 capacity를 최대화 해야하는 상황이라면 이 경우에도 RAID 5가 좋은 선택이다.  </p>
<p>여기서 살펴본 RAID 디자인 말고도 다른 여러가지 디자인이 존재한다. 예를들어 RAID 6은 multiple disk failure를 허용한다.<br>RAID는 hardware 자체로 구현되어 제공되기도 하고 software로도 구현되어 제공될 수 있다. </p>
<br/>

<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.amazon.com/Operating-Systems-Three-Easy-Pieces-ebook/dp/B00TPZ17O4">https://www.amazon.com/Operating-Systems-Three-Easy-Pieces-ebook/dp/B00TPZ17O4</a></li>
</ul>
<br/>
<br/>
<br/>
<br/>



</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-03-24T12:16:21.000Z" title="24/03/2020, 21:16:21">2020-03-24</time>&nbsp;게시 됨</span><span class="level-item"><a class="link-muted" href="/categories/maven/">maven</a></span><span class="level-item">41분안에 읽기 (약 6083 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/03/24/maven-basic/">Maven(메이븐) 이란?</a></h1><div class="content"><p>이 글은 박재성님이 쓰신 <a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;ejkGb=KOR&amp;barcode=9788979148138" rel="external nofollow noopener noreferrer" target="_blank">자바세상의 빌드를 이끄는 메이븐</a>이라는 책과 <a href="https://maven.apache.org/index.html" rel="external nofollow noopener noreferrer" target="_blank">메이븐 공식문서</a>를 보고 정리한 글입니다.<br>책이 있으신분은 메이븐 개념을 한번 머릿속에 정리하고 싶을때 읽으시면 매우 좋습니다. 책에 스토리로 이끌어가는 부분이 있어 매우 재밌게 읽을 수 있습니다.<br>다만, 책이 절판되어 책을 구하고싶으신 분들은 아마 알라딘이나 다른 곳에서 중고서적으로 구매를 하셔야 합니다.  </p>
<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>메이븐은 자바기반 프로젝트를 빌드하고 관리하기 위한 툴이다.<br>요즘은 Gradle이 많이 쓰이지만 아직 maven을 사용하고 있는 프로젝트도 많다.<br>메이븐은 빌드 프로세스를 최대한 쉽게 하는것을 목표로 하고 이 뿐만 아니라 프로젝트에 질높은 정보를 제공하고, 단일 빌드시스템을 제공하는 것을 목표로 한다.  </p>
<p>다른 build tool 없이 자바프로젝트를 개발하게 되면 의존성관리 등 신경써야할게 한두가지가 아니다. 메이븐이 이를 도와준다.<br>메이븐의 장점은 다음과 같다.  </p>
<ul>
<li>편리한 의존관계 관리를 지원한다.</li>
<li>모든 프로젝트가 일관된 프로젝트 디렉토리 구조, 빌드 프로세스를 유지할 수 있다.</li>
<li>다양한 메이븐의 플러그인을 활용할 수 있다.</li>
<li>프로젝트의 template을 만들수있다.</li>
</ul>
<p>메이븐은 저장소를 지원해서 메이븐만 설치하면 프로젝트 build에 필요한 라이브러리, plugin을 저장소에서 우리의 PC로 자동으로 다운로드한다. 다운로드한 라이브러리들은 특정 디렉터리에 위치하게 되는데 이를 localRepository(로컬저장소)라고 부른다. 기본적으로는 <code>~/.m2/repository</code> 에 위치하고 settings.xml로 설정을 변경할 수도 있다.<br>또 메이븐은 처음 생성하는 프로젝트 종류에 따라 기반이 되는 template을 제공한다. 이를 이용해서 메이븐 기반 프로젝트를 생성할 수 있는데, 그러면 프로젝트의 기본적인 뼈대를 자동으로 생성할 수 있다. 메이븐의 이 같은 기능을 archetype이라고 한다.  </p>
<p>메이븐 공식문서의 <a href="https://maven.apache.org/guides/getting-started/" rel="external nofollow noopener noreferrer" target="_blank">getting started</a>에서 처음 메이븐 프로젝트를 만들게 될때도 archetype을 사용한다.<br>다음 명령어로 메이븐 프로젝트를 생성해보자.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -B archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4</span><br></pre></td></tr></table></figure></p>
<p>이를 실행하면 <code>my-app</code> 프로젝트의 디렉터리가 만들어지고 그 안에 pom.xml 파일이 생성된다.<br>메이븐은 source code와 test code를 분리해서 관리하는데 source code는 src/main/java 에 위치하고, test code는 src/test/java 에 위치한다.<br>여기서 사용한 groupId, artifactId는 뒷부분에서 다루겠다.  </p>
<h2 id="메이븐-기본명령어"><a href="#메이븐-기본명령어" class="headerlink" title="메이븐 기본명령어"></a>메이븐 기본명령어</h2><p>메이븐 명령어는 다음과 같은 형태를 가진다.<br><code>mvn [options] [goal] [phase]</code>
위의 명령어에서도 사용했던 -D 옵션들은 메이븐 설정파일(pom.xml)에 인자를 전달한다.<br>예를 들어 단위테스트를 실행하지 않으려면 <code>mvn -Dmaven.test.skip=true [&lt;phase&gt;]</code>와 같이 실행할 수 있다.
메이븐에는 phase와 goal 개념이 있는데 이들을 이용하며 빌드를 실행할 수 있고, 빌드를 실행할 때 여러개의 phase와 goal을 실행할 수 있다. 예를들어 다음과 같이 다양한 형태로 실행이 가능하다.<br><code>mvn clean test</code>: clean phase와 test phase를 실행한다.<br><code>mvn clean compiler:compile</code>: clean phase와 compiler plugin의 compile goal을 실행한다.<br>phase와 goal은 밑에서 자세히 다루겠다.  </p>
<h2 id="Pom-xml"><a href="#Pom-xml" class="headerlink" title="Pom.xml"></a>Pom.xml</h2><p>위의 메이븐 archetype:generate 명령어로 메이븐 프로젝트를 생성했으면 pom.xml 파일이 생성된다. POM은 Project Object Model을 의미한다. 그러면 pom.xml의 각 element 들을 살펴본다.  </p>
<p>먼저 생성된 pom.xml은 다음과 같다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;my-app&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">  &lt;name&gt;maven-app&lt;/name&gt;</span><br><span class="line">  &lt;!-- FIXME change it to the project&apos;s website --&gt;</span><br><span class="line">  &lt;url&gt;http://www.example.com&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">  .. 이하생략 ..</span><br></pre></td></tr></table></figure></p>
<ul>
<li>project: pom.xml의 최상위 element</li>
<li>modelVersion: POM version. 최근버전이 4.0.0이다.</li>
<li>artifactId: project를 식별하는 id를 의미한다. groupId 안에서 여러개의 project가 있을 수 있다. </li>
<li>groupId: project를 생성하는 조직의 고유 id를 결정한다. 도메인 이름을 많이 사용하는데 꼭 그럴필요는 없다.<br>groupId + artifactId는 값이 유일해야한다. 그렇지 않으면 중앙저장소에서 충돌한다.</li>
<li>packaging: 어떤 방식으로 패키징할지 결정한다. jar, war 등을 설정가능하다.</li>
<li>version: project의 현재 버전을 의미한다. 프로젝트 개발중에는 SNAPSHOT을 suffix로 사용가능하다.<br>SNAPSHOT은 maven의 예약어이며 SNAPSHOT을 사용하면 라이브러리를 다른방식으로 관리한다.</li>
<li>name: project 이름이다.</li>
<li>url: project url이 있다면 이를 기입한다.</li>
<li>dependencies: 프로젝트와 의존관계에 있는 라이브러리들을 관리한다.</li>
</ul>
<p>각 프로젝트의 pom.xml은 기본적으로 최상위 POM이라고 불리는 설정을 상속한다. 그래서 pom.xml의 설정내용이 단순하더라도 메이븐의 기본 규약들을 전부다 따르는 것이 가능하다. 실제 정의된 설정들을 보려면 다음 명령어를 사용하면 된다.<br><br>
<code>mvn help:effective-pom</code><br><br>
설정되어있는 repository 정보를 담고있는 repositories 태그, plugin 설정정보를 담는 태그등 기존 pom.xml에 보이지 않았던 태그들을 볼 수 있다. 이 내용들이 기본적으로 최상위 POM에 존재했기 때문에 우리가 만든 project의 pom.xml은 단순하게 가져갈 수 있다.  </p>
<h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>메이븐은 모든 빌드 단위가 이미 정의되어 있으며 이는 개발자가 임의로 변경할 수가 없다.
여기서 말하는 빌드 단위란 compile, test, package, deploy 등을 말한다.<br>메이븐은 이와같이 미리 정의되어 있는 빌드 순서를 lifecycle이라고 하며 메이븐은 3개의 lifecycle을 제공한다.</p>
<ol>
<li>compile, test, package, deploy를 담당하는 기본 lifecycle</li>
<li>빌드 결과물 제거를 위한 clean lifecycle</li>
<li>project document site를 생성하는 site lifecycle이다.</li>
</ol>
<p>메이븐은 기본적으로 빌드후의 모든 산출물을 target 디렉터리에서 관리한다.  </p>
<p>target 디렉터리에 생성되는 하위디렉터리는 다음과 같다.  </p>
<ul>
<li>target/classes: src/main/java의 소스코드가 컴파일된 class 파일들과 src/main/resources 디렉터리의 자원이 복사된다.</li>
<li>target/test-classes: src/test/java의 소스코드가 컴파일된 class 파일들과 src/test/resources 디렉터리의 자원이 복사된다.</li>
<li>target/surefire-reports: report 문서들이 위치한다.</li>
</ul>
<h4 id="기본-Lifecycle"><a href="#기본-Lifecycle" class="headerlink" title="기본 Lifecycle"></a>기본 Lifecycle</h4><p>기본 lifecycle을 활용해 source code를 compile, test 등을 할 수 있는데 각 phase들을 살펴보면 다음과 같다.  </p>
<ul>
<li>process-resources: src/main/resources의 모든 자원을 target/classes 로 복사한다.</li>
<li>compile: src/main/java에 있는 source code를 compile한다.</li>
<li>process-test-resources: src/test/resources의 모든 자원을 target/test-classes 로 복사한다.</li>
<li>test-compile: src/test/java에 있는 source code를 compile한다. </li>
<li>test: Junit 같은 unit test framework로 test를 진행하고 test가 실패하면 빌드실패로 간주한다.<br>결과물을 target/surefire-reports 디렉터리에 생성한다. </li>
<li>package: pom.xml의 packaging 값에 따라 압축한다.(jar, war)</li>
<li>install: local repository에 압축한 파일을 배포한다.</li>
<li>deploy: 원격저장소에 압축한 파일을 배포한다.</li>
</ul>
<p>이처럼 maven 기본 lifecycle은 여러개의 phase로 구성되어 있으며, 각 phase는 의존관계를 가진다.<br>process-resources ← compile ← process-test-resources ← test-compile ← test ← package<br>이 순으로 의존관계를 가지고 있어서 package phase를 실행(mvn package)하면 의존관계에 있는 test phase가 먼저 실행되고, test phase는 compile phase에 의존관계가 있기때문에 compile phase가 먼저 실행된다.<br>따라서 package phase를 실행하면 process-resources → compile → process-test-resources → test-compile → test → package 순으로 빌드가 진행된다.  </p>
<p>process-resources phase는 src/main/resources 에 있는 모든 자원을 test/classes 디렉터리로 복사하는데, 
만약 다른 디렉터리에도 자원이 존재한다면 pom.xml에 따로 설정할 수 있다.  </p>
<p>package phase는 jar나 war형태로 압축하여 target 디렉터리에 위치시킨다.<br><code>&lt;build&gt;/&lt;finalName&gt;</code>에 값이 설정되어 있으면 {finalName}.{packaging} 형태로 압축파일이 생기고,<br>값이 설정 안되어있다면 {artifactId}-{version}.{packaging} 형태로 된다.  </p>
<p>clean phase는 빌드한 결과물들을 제거하는 phase인데 이는 다른 phase와 관련이 없다.<br>clean phase를 실행하지 않고 다른 phase를 실행할 때 불필요한 산출물들 때문에 오류가 날 수 있으므로 clean을 실행하고 빌드하는 습관을 가지면 좋다.  </p>
<h4 id="Clean-Lifecycle"><a href="#Clean-Lifecycle" class="headerlink" title="Clean Lifecycle"></a>Clean Lifecycle</h4><p>clean lifecycle은 빌드를 통해 나온 산출물을 모두 삭제한다.<br>target directory를 삭제하는 것과 동일하다.</p>
<h4 id="Site-Lifecycle"><a href="#Site-Lifecycle" class="headerlink" title="Site Lifecycle"></a>Site Lifecycle</h4><p>site lifecycle은 사용안하는 경우가 많은데 핵심만 짚고 넘어가자면,<br>site, site-deploy phase를 사용해 실행가능하다. site lifecycle은 메이븐에 설정되어 있는 기본설정, 플러그인 설정에 따라 target/site directory에 문서 사이트를 생성한다. site-deploy는 이를 배포한다.  </p>
<h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><p>메이븐에서 제공하는 모든 기능은 plugin을 기반으로 동작한다.<br>메이븐 phase 또한 메이븐 plugin을 통하여 실질적인 작업이 실행된다. 따라서 phase가 실행되는 과정을 이해하려면 maven plugin을 먼저 이해해야 한다.  </p>
<p>사용하고자 하는 maven plugin이 있다면 pom.xml에 다음과 같이 설정한다.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.1&lt;/version&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p>
<p>이와 같이 사용하고자 하는 plugin의 groupId, artifactId, version을 명시하면 된다.<br>version을 생략하면 가장 최신버전의 plugin이 설치된다.<br>메이븐 plugin은 하나의 plugin에서 여러 작업을 실행할 수 있도록 지원하는데 여기서 각각 실행할 수 있는 작업을 goal이라고 정의한다.<br>위의 compiler plugin은 하나지만 이 플러그인이 지원하는 goal은 compile(source directory의 compile), testCompile(test directory의 compile) 등이 있다.  </p>
<p>plugin은 다음과 같이 실행할 수 있다.<br><code>mvn groupId:artifactId:version:goal</code>  </p>
<p>예를들어 앞의 compiler plugin의 compile goal은 다음과 같이 실행한다.<br><code>mvn org.apache.maven.plugins:maven-compiler-plugin:2.1:compile</code>  </p>
<p>만약 settings.xml에 pluginGroup이 설정이 되어있다면 groupId를 생략이 가능하고,<br>version을 생략하면 local repository에 있는 가장 최신 버전의 플러그인을 사용하며,<br>plugin 이름이 <code>maven-$name-plugin</code> 이나 <code>$name-maven-plugin</code> 형식을 따른다면 $name 값만 명시할 수 있다.<br>앞에서 실행했던 compile 플러그인을 다음과 같이 실행할 수 있다.<br><code>mvn compiler:compile</code></p>
<p>앞부분에서 실행했던 <code>mvn archetype:generate</code> 명령도 <code>mvn org.apache.maven.plugins:maven-archetype-plugin:generate</code>를 축약한 것이다.  </p>
<p>메이븐은 매우 많은 플러그인들을 활용할 수 있는게 큰 장점이다. 다양한 플러그인을 제공하고 있어서 원하는 개발환경을 얼마든지 만들어 나갈 수 있다.</p>
<h2 id="Phase와-Goal"><a href="#Phase와-Goal" class="headerlink" title="Phase와 Goal"></a>Phase와 Goal</h2><p>메이븐에서 phase는 build lifecycle에서 각 단계와 순서를 정의하는 개념으로 실제로 빌드작업을 하지는 않는다.<br>실제 빌드작업은 해당 phase와 연결되어 있는 plugin의 goal에서 진행한다.<br><code>mvn compile</code>은 compile phase를 실행한 것인데 이는 compile phase와 연결되어 있는 compiler plugin의 compile goal이 실행되면서 컴파일 작업을 진행한다.<br>기본 lifecycle에서 phase를 실행할 때 기본으로 연결된 plugin의 goal을 실행하는 구조이다.<br>기본 lifecycle에서 phase에 연결되어 있는 plugin을 실행할 때에는 자동으로 메이븐 중앙저장소에서 plugin을 다운로드 한다.  </p>
<p>phase와 goal과의 관계를 보여주는 그림이다.  </p>
<p align="center">
    <img alt="phase와 goal의 관계" src="/images/maven-phase-goal.jpeg">
</p>

<p>각 핵심 phase 별로 구체적인 내용을 알아보자.  </p>
<h4 id="mvn-compile"><a href="#mvn-compile" class="headerlink" title="mvn compile"></a>mvn compile</h4><p>compile phase를 실행하면 먼저 의존관계에 있는 process-resources phase가 먼저 실행된다. process-resources phase는 src/main/resources 디렉터리에 있는 모든 자원을 target/classes 디렉터리로 복사한다.<br>만약 src/main/java 안에서도 소스와 같은 패키지로 관리하는 리소스들이 있고 이들또한 target/classes에 복사되기를 원한다면 다음과 같은 설정을 하면된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">  &lt;resources&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">      &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">      &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">      &lt;excludes&gt;</span><br><span class="line">        &lt;exclude&gt;**/*.java&lt;/exclude&gt;</span><br><span class="line">      &lt;/excludes&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">  &lt;/resources&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p>
<p>그러면 compile phase 실행시 src/main/java에 있는 <code>*.java</code> 파일을 제외한 모든 설정파일을 target/classes 로 복사한다.<br>resource plugin과 compiler plugin 에 대한 자세한 정보는 다음 공식문서에서 확인할 수 있다.<br>resources plugin : <a href="https://maven.apache.org/plugins/maven-resources-plugin/" rel="external nofollow noopener noreferrer" target="_blank">resources-plugin</a><br>compiler plugin : <a href="https://maven.apache.org/plugins/maven-compiler-plugin/" rel="external nofollow noopener noreferrer" target="_blank">compiler-plugin</a>  </p>
<h4 id="mvn-test"><a href="#mvn-test" class="headerlink" title="mvn test"></a>mvn test</h4><p>test phase를 실행하면 process-test-resources phase가 먼저 실행되면서 src/test/resources 디렉터리의 자원복사를 먼저 진행한다.<br>그리고 test-compile phase에서 src/test/java 디렉터리의 test code들을 컴파일한다.<br>test phase는 target/test-classes 에 컴파일한 단위 테스트 클래스를 실행하고 그 결과물을 target/surefire-reports 디렉터리에 생성한다.<br>기본적으로 test phase는 target/test-classes 에 있는 모든 단위 테스트 클래스를 실행하는데 특정 테스트 suite 별로 실행할 필요가 있다면 test option을 사용할 수 있다.  </p>
<p><code>mvn -Dtest=MyUnitTest test</code><br><br>
이와 같이 특정 테스트 클래스만 실행할 수 있고 여러개의 test 클래스 들을 실행하고 싶다면 쉼표로 여러개를 정의하면된다.  </p>
<h4 id="mvn-package"><a href="#mvn-package" class="headerlink" title="mvn package"></a>mvn package</h4><p>package phase는 compile, test-compile, test, package 순으로 실행된 후 jar, war 파일이 target 디렉터리 하위에 생성된다.<br><code>&lt;build&gt;/&lt;fileName&gt;</code> 에 값이 설정되어 있고 jar로 패키징을 하게되면 {finalName}.jar 형태로 jar 파일이 생성된다. 만약 finalName element가 설정되어 있지 않다면 {artifactId}-{version}.{packaging} 이 압축파일 그리고 디렉터리 이름이 된다.<br>예를들어, finalName element가 설정되어있지 않고 pom.xml 설정이 다음과 같다면
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">  &lt;groupId&gt;io.github.tk-one&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;myapp&lt;/artifactId&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p>
<p>파일은 다음 위치에 생성된다.<br><code>target/myapp-1.0-SNAPSHOT/myapp-1.0-SNAPSHOT.war</code>  </p>
<h4 id="mvn-install"><a href="#mvn-install" class="headerlink" title="mvn install"></a>mvn install</h4><p>install phase는 package phase와 의존관계에 있기때문에 package phase를 먼저 실행한다. package phase에서 jar or war 파일로 압축을 완료하면 이를 local repository에 배포한다.</p>
<h4 id="mvn-deploy"><a href="#mvn-deploy" class="headerlink" title="mvn deploy"></a>mvn deploy</h4><p>deploy phase는 jar or war 파일을 원격저장소에 등록한다.</p>
<p><br>  </p>
<h2 id="라이브러리-의존관계"><a href="#라이브러리-의존관계" class="headerlink" title="라이브러리 의존관계"></a>라이브러리 의존관계</h2><p>메이븐은 의존관계에 있는 라이브러리를 관리하기 위해 의존 라이브러리 관리기능을 제공한다. 이는 메이븐의 lifecycle과 더불어 메이븐의 핵심기능이기 때문에 반드시 이해하는게 좋다.  </p>
<p>메이븐 저장소는 로컬저장소와 원격저장소로 나뉜다.  </p>
<h4 id="로컬저장소"><a href="#로컬저장소" class="headerlink" title="로컬저장소"></a>로컬저장소</h4><p>로컬저장소는 개발자 PC에 있는 저장소로 메이븐을 빌드할때 다운로드하는 라이브러리나 플러그인을 관리 및 저장한다.<br>로컬저장소는 기본값으로는 <code>~/.m2/repository</code> 에 위치한다.  </p>
<h4 id="원격저장소"><a href="#원격저장소" class="headerlink" title="원격저장소"></a>원격저장소</h4><p>원격저장소는 외부에 위치하는 저장소로 사내에서 사용하는 저장소도 있고 중앙저장소라고 불리는 오픈소스 라이브러리나, 메이븐 플러그인 등을 저장하고 있는 저장소도 있다. 중앙저장소는 원격저장소 중 하나라고 생각하면 된다.  </p>
<p>메이븐은 빌드를 할때 로컬저장소에 이미 다운로드한 라이브러리가 있으면 원격저장소에서 다운로드 하지않고 로컬저장소에 있는 라이브러리르 사용한다. 메이븐이 다운로드 하고자 하는 저장소는 repositories 태그로 설정할 수 있다.<br>기본적으로 우리가 repositories 태그로 설정을 안하고 다운로드할 수 있는 이유는 최상위 POM에 이미 정의가 되어있기 때문이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">  &lt;repositories&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">      &lt;id&gt;central&lt;/id&gt;</span><br><span class="line">      &lt;name&gt;Central Repository&lt;/name&gt;</span><br><span class="line">      &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">  &lt;/repositories&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p>
<p>여러개의 repository들을 추가할 수 있는데 그러면 메이븐은 라이브러리를 다운로드할때 repositories 태그에 있는 저장소 순서대로 다운로드를 시도한다.  </p>
<p>위에서 생성한 myapp에서는 다음과 같이 dependencies 태그로 라이브러리를 관리한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p>
<p>이와 같이 설정하고 빌드하면 메이븐은 먼저 로컬저장소에 해당 라이브러리가 있는지 확인한다.<br>없다면 메이븐은 중앙저장소에서 junit 4.11 버전이 있는지 확인하고 있다면 jar 파일을 로컬저장소에 다운로드한다.<br>중앙저장소에 해당 라이브러리와 버전이 존재하는지 확인할 때에는 위에 repository 설정에 적힌 url을 바라보고<br><a href="https://repo.maven.apache.org/maven2/junit/junit/4.11/junit-4.11.jar" rel="external nofollow noopener noreferrer" target="_blank">https://repo.maven.apache.org/maven2/junit/junit/4.11/junit-4.11.jar</a> 파일이 있는지를 파악한다.<br>이와 같이 설정하고 빌드하면 메이븐은 중앙저장소에서 junit 4.11 버전의 jar 파일을 로컬저장소에 다운로드한다.<br>로컬저장소에 다운로드 받는 위치는 기본적으로 다음과 같다.<br>~/.m2/repository/junit/junit/4.11/junit-4.11.jar  </p>
<p>그리고 메이븐은 로컬저장소에 다운로드한 라이브러리를 활용해 src/main/java 그리고 src/test/java 에 있는 source code들을 컴파일한다.  </p>
<p>version을 LATEST 혹은 RELEASE로 설정할 수도 있는데 그러면 항상 가장 최신버전의 라이브러리와 의존관계를 갖게된다.<br>또, 한번 로컬저장소에 다운로드한 라이브러리는 다시 원격저장소에서 다운로드하지 않는데 이부분에서 애플리케이션이 개발단계에 있어 코드가 지속적으로 변경되는 상황이라면 SNAPSHOT을 활용하자.<br>version 정보에 SNAPSHOT을 포함하게되면 빌드할 때마다 가장 최근에 배포한 라이브러리가 있는지 확인하고 로컬저장소에 있는것보다 최신일경우 이를 다운로드한다.  </p>
<h4 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h4><p>메이븐에서는 사용하는 라이브러리의 성격에 따라 scope를 지정할 수 있다.<br>JUnit 라이브러리의 경우 실제 배포할때는 필요없고 테스트를 진행할때만 필요하다. 이런경우 scope를 test로 주면된다.  </p>
<p>scope는 6가지 종류가 있다.  </p>
<ul>
<li>compile: default scope이다. compile 및 deploy시 같이 제공해야하는 라이브러리이다.</li>
<li>provided: compile 시점엔 필요하지만 deploy에 포함할 필요는 없는경우 사용한다.</li>
<li>runtime: compile에는 필요없지만 runtime에는 필요한 경우 사용한다.</li>
<li>test: test 시점에만 사용하는 라이브러리에 설정한다.</li>
<li>system: provided scope와 비슷한데 로컬저장소에서 관리되는 jar파일이 아닌 우리가 직접 jar 파일을 제공해야한다.</li>
<li>import: 다른 pom.xml 에 정의되어있는 의존관계설정을 가져온다.  </li>
</ul>
<h2 id="Dependency-Mechanism"><a href="#Dependency-Mechanism" class="headerlink" title="Dependency Mechanism"></a>Dependency Mechanism</h2><p>Dependency Mechanism은 메이븐의 핵심중 하나이다.<br>그러므로 메이븐이 어떻게 의존성을 관리하는지는 꼭 이해하고 넘어가는게 좋다.  </p>
<h4 id="Dependency-Transitive-의존성-전이"><a href="#Dependency-Transitive-의존성-전이" class="headerlink" title="Dependency Transitive(의존성 전이)"></a>Dependency Transitive(의존성 전이)</h4><p>프로젝트에서 의존하는 라이브러리들의 숫자는 제한이 없지만 의존성 cycle이 있으면 문제가 발생한다.<br>프로젝트에 외부 라이브러리를 하나씩 추가할때마다 그 라이브러리가 또 의존하고있는 라이브러리를 또 추가해야 하므로 의존관계에 있는 라이브러리 숫자가 증가한다.<br>예를들어, project A가 B, C에 의존하고있다면 B가 의존하고있는 D, E, F 라이브러리가 또 필요할 것이고 또 D 가 의존하는 G 라이브러리도 필요할 것이다. 연쇄작용으로 의존하는 프로젝트는 점점 커진다.<br>참고로 메이븐은 의존성이 있는 라이브러리가 또 어떤 라이브러리에 의존성을 가지고있는지 알기위해 jar 파일을 다운로드 하는 동시에 해당 라이브러리의 pom파일도 같이 다운로드 한다.<br>메이븐은 위처럼 프로젝트 라이브러리 숫자가 급격히 증가하는 문제점을 해결하기 위해 라이브러리 제한이 가능하도록 의존성 전이 설정을 지원한다. </p>
<ul>
<li><p>Dependency mediation: 같은 의존성의 여러버전을 마주치게 되었을때 artifact의 어떤 버전을 사용할지 결정한다.<br>메이븐은 이때 더 가까운 의존관계에 있는 버전의 의존관계를 선택한다.<br>예를들어 다음과 같은 의존성이 있다고 가정한다.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  A</span><br><span class="line">├── B</span><br><span class="line">│   └── C</span><br><span class="line">│       └── D 2.0</span><br><span class="line">└── E</span><br><span class="line">    └── D 1.0</span><br></pre></td></tr></table></figure>
<p>이 예에서는 A를 build할때 D 1.0이 사용된다. 왜냐하면 A -&gt; B -&gt; C -&gt; D 2.0 보다 A -&gt; E -&gt; D 1.0 이 더 가깝기 때문이다.<br>여기서 서로 depth 가 같은 상황이라면 먼저 명시된 라이브러리의 버전이 사용된다.<br>만약 project A의 pom.xml에 직접 version을 적어주면 그 버전을 사용한다.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  A</span><br><span class="line">├── B</span><br><span class="line">│   └── C</span><br><span class="line">│       └── D 2.0</span><br><span class="line">├── E</span><br><span class="line">│   └── D 1.0</span><br><span class="line">│</span><br><span class="line">└── D 2.0</span><br></pre></td></tr></table></figure>
<p>이처럼 A에 직접 D 2.0 의 의존성을 추가하면 D 2.0 을 사용한다.  </p>
</li>
<li><p>Dependency management: 메이븐의 <code>&lt;dependencyManagement&gt;</code> element로 의존관계에 있는 artifact의 버전을 직접 명시랄 수 있다.</p>
</li>
<li>Dependency scope: 현재 빌드상태에 맞는 라이브러리만 의존관계를 포함한다.<br>즉, test scope를 가지는 경우 최종 배포산출물을 빌드하는 시점에는 포함되지 않는다.  </li>
<li>Excluded dependencies: 만약 A -&gt; B -&gt; C와 같이 의존성이 있으면 project A에서 명시적으로 project C에 대한 의존성을 <code>&lt;exclusion&gt;</code>태그를 사용해 명시적으로 제외시킬 수 있다.</li>
<li>Optional dependencies: 만약 A -&gt; B -&gt; C와 같이 의존성이 있고 project B에 C가 optional로 설정이 되어있으면 project A를 빌드할때 project C에 대한 의존관계를 가지지 않는다.  </li>
</ul>
<p>메이븐의 Dependency Transitive가 의존관계를 최대한 잘 설정해 주겠지만 pom.xml에 항상 라이브러리의 명확한 version을 명시하는게 좋다.<br>현재 프로젝트에서 의존하고있는 라이브러리의 tree를 보고싶다면 다음 plugin의 goal을 사용하면 좋다.<br><code>mvn dependency:tree</code>  </p>
<h2 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h2><p>pom.xml에서 발생하는 중복설정은 속성(property)를 정의하여 개선할 수 있다.<br>보통 공통된 버전관리에 많이 사용하고는 하는데 예제를 보면 바로 이해할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">    &lt;spring.version&gt;3.0.1.RELEASE&lt;/spring.version&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;spring.version&#125;&gt;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p>
<p>속성은 <code>&lt;properties&gt;</code> element에서 <code>&lt;property.name&gt;value&lt;/property.name&gt;</code> 형태로 정의한다.<br>그리고 이렇게 정의한 내용은 pom.xml 파일내에서 <code>${property.name}</code> 으로 접근할 수 있다.<br><br> 
<br> </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-01-03T10:44:29.000Z" title="03/01/2020, 19:44:29">2020-01-03</time>&nbsp;게시 됨</span><span class="level-item"><a class="link-muted" href="/categories/network/">network</a></span><span class="level-item">12분안에 읽기 (약 1737 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/03/smtp/">인터넷 메일시스템 (SMTP)</a></h1><div class="content"><p><br></p>
<p>이 포스트에서는 Application Layer의 <strong>SMTP (Simple Mail Transfer Protocol)</strong> 에 대해 알아본다.<br>먼저, SMTP를 보기전에 인터넷 전자메일 시스템이 어떤식으로 동작하는지 알고있어야 한다.  </p>
<h2 id="Mail-System"><a href="#Mail-System" class="headerlink" title="Mail System"></a>Mail System</h2><p>인터넷 메일 시스템은 크게 <strong>user agent, 메일서버, SMTP</strong> 이 3가지 요소로 구성되어 있다.<br>아래의 그림을 보면서 이해하면 쉽다.</p>
<p><img src="/images/mail_system_topology.png" alt="mail_system"></p>
<ul>
<li><p><strong>user agent</strong><br>MS의 Outlook을 생각하면 쉽다. user agent는 사용자가 메일을 읽고, 작성하고, 전송할 수 있도록 해준다.</p>
</li>
<li><p><strong>메일서버</strong><br>사용자가 메일 작성을 끝내면 user agent는 메시지를 메일서버로 보내게되고, 여기서 메시지는 메일서버의 output 메시지큐에 들어가게 된다.<br>여기서의 메일서버는 송신자의 메일서버를 의미한다.<br>송신자의 메일서버에서 수신자의 메일서버로 메시지가 전송되면, 메일들은 수신자의 메일서버안의 <strong>메일박스(mailbox)</strong>안에 저장되고 유지된다.<br>만약, 수신자의 메일서버가 다운된 상황에서 송신자가 메일을 보내면 어떻게 될까?<br>송신자가 메일을 전송하면, 먼저 메일이 송신자의 메일서버에 도착한다. 그리고 송신자의 메일서버는 메일을 수신자의 메일서버로 전송할 수 없을때, 메시지 큐(message queue)에 보관하고 있다가, 주기적으로 메일전송을 시도한다.</p>
</li>
<li><p><strong>SMTP</strong><br>SMTP는 Application layer에서 작동하는 메일전송 프로토콜이다. 위의 메일서버 설명에서, 한 메일서버에서 다른 메일서버로 메시지(메일)을 전송할때 사용하는 프로토콜이 SMTP이다.<br>이뿐만 아니라, 송신자의 user agent에서 본인의 메일서버로 메일을 전송할때도 SMTP가 사용된다.<br>SMTP는 TCP위에서 작동한다. 참고로 SMTP는 HTTP보다 훨씬 더 오래전부터 사용되었다.</p>
</li>
</ul>
<p>이 설명을 기반으로 메일을 전송하는 간단한 시나리오를 보자.<br>A가 B에게 메일을 전송하는 상황이다.  </p>
<ol>
<li>A가 user agent를 통해 B에게 메일 내용을 작성하고 전송버튼을 누른다.</li>
<li>A의 user agent는 메시지를 A의 메일서버에 보내게 되고, 메시지는 메일서버의 output message queue에 위치한다.</li>
<li>A의 메일서버에서 동작하는 SMTP 클라이언트는 output message queue에 쌓여있는 메시지를 B의 메일서버로 전송하기 위해 먼저 TCP연결을 맺는다.</li>
<li>TCP가 맺어진 후, SMTP 핸드쉐이킹을 하고 SMTP 프로토콜에 따라 B의 메일서버로 전송한다.</li>
<li>B의 메일서버는 메시지를 수신한 후, 그 메시지를 B의 메일박스(mailbox)에 놓는다.</li>
<li>B는 이후에 user agent를 실행하여 메일을 읽을 수 있다.</li>
</ol>
<p>인터넷 메일 시스템은 대충 이런식으로 작동한다.<br>(2번에서 A의 user agent가 메시지를 A의 메일서버로 보낸다고 되어있는데, 사실 여기서도 SMTP 프로토콜을 통해 전달된다.)<br>그러면 이제 SMTP를 좀 더 자세히 보도록 한다.</p>
<h2 id="SMTP-Simple-Mail-Transfer-Protocol"><a href="#SMTP-Simple-Mail-Transfer-Protocol" class="headerlink" title="SMTP (Simple Mail Transfer Protocol)"></a>SMTP (Simple Mail Transfer Protocol)</h2><p>대부분의 Application layer protocol 처럼 SMTP는 송신자의 메일서버에서 수행하는 클라이언트와, 수신자의 메일서버에서 수행되는 서버를 가지고 있다. 메일서버가 상대 메일서버로 전송할때는 SMTP의 클라이언트로 동작하는 것이고, 메일서버가 상대 메일서버로 부터 메일을 받을때는 SMTP 서버로 동작하는 것이다. HTTP를 떠올리면 쉽다.  </p>
<p>메일서버에서 상대 메일서버로 메일을 보내는 상황에서, 먼저 클라이언트 SMTP는 서버 SMTP의 25번 포트로 TCP연결을 맺는다. 만약 서버가 죽어있으면 클라이언트는 나중에 다시 시도한다.<br>TCP 연결이 맺어지면, 클라이언트와 서버는 SMTP 핸드쉐이킹을 수행한다. 이 SMTP 핸드쉐이킹 과정에서 클라이언트는 송신자와 수신자의 email 주소를 제공한다.  </p>
<p>핸드쉐이킹 과정을 마치면, 클라이언트는 메시지를 보낸다.  </p>
<p>SMTP 클라이언트와 SMTP 서버 사이의 메시지 전달과정을 예를들어 살펴보자.<br>클라이언트 호스트네임은 github.io 이고, 서버 호스트네임은 korea.ac.kr 이라고 하자.<br>C는 클라, S는 서버를 나타내고 TCP 연결 직후의 상황을 가정한다.<br>메일 내용은 “Hello, this is TK-one. Can I know the result of the interview?” 이다.</p>
<p><code>
S: 220 korea.ac.kr
C: HELO github.io
S: 250 Hello github.io, pleased to meet you
C: MAIL FROM: <a href="mailto:&#116;&#107;&#45;&#111;&#x6e;&#x65;&#64;&#103;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#105;&#111;">&#116;&#107;&#45;&#111;&#x6e;&#x65;&#64;&#103;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#105;&#111;</a>
S: 250 <a href="mailto:tk-one@github.io" rel="external nofollow noopener noreferrer" target="_blank">tk-one@github.io</a> … Sender ok
C: RCPT TO: <a href="mailto:&#x6b;&#105;&#109;&#x40;&#x6b;&#111;&#114;&#101;&#97;&#x2e;&#x61;&#x63;&#46;&#107;&#114;">&#x6b;&#105;&#109;&#x40;&#x6b;&#111;&#114;&#101;&#97;&#x2e;&#x61;&#x63;&#46;&#107;&#114;</a>
S: 250 <a href="mailto:kim@korea.ac.kr" rel="external nofollow noopener noreferrer" target="_blank">kim@korea.ac.kr</a> … Recipient ok
C: DATA
S: 354 Enter mail, end with “.” on a line by itself
C: Hello, this is TK-one. (메일내용)
C: Can I know the result of the interview? (메일내용)
C: .
S: 250 Message accepted for delivery
C: QUIT
S: 221 korea.ac.kr closing connection
</code></p>
<p>클라이언트는 5개의 명령(<strong>HELO, MAIL FROM, RCPT TO, DATA, QUIT</strong>)을 내리며 하나의 점(.)으로 된 라인을 송신하면 이는 메시지의 끝을 의미한다.<br>서버는 각 명령에 대해 답하며, 각 응답은 응답코드와 옵션 설명을 갖고 있다.<br>그리고 주의할 점이 있는데, SMTP는 메시지의 body와 header를 포함하여 전부 7bit ASCII 코드로 작성되어야 한다.<br>HTTP는 이런 제한이 없는 반면, SMTP는 한글이나 binary 데이터 처럼 ASCII가 아닌 문자를 포함한다면 반드시 이 메시지는 전송되기 전에 7bit ASCII로 인코딩이 되어야한다.  </p>
<p>이렇게 SMTP를 통해 한 메일서버에서 다른 메일서버로 메시지가 전달된다.<br>그렇다면 수신자는 자신의 PC에서 user agent를 통해 자신의 메일서버에 있는 메시지들을 어떻게 얻을 수 있을까?<br>수신자의 user agent는 메일을 가져오기위해 SMTP를 사용할 수는 없다. 왜냐하면 SMTP는 푸시(push)용 프로토콜인 반면, 메시지를 가져오는 것은 풀(pull) 동작이기 때문이다.<br>여기서는 메일서버로부터 자신의 user agent로 메시지를 가져오기 위해 특별한 메일 접속 프로토콜을 사용한다. 이들중엔 <strong>POP3(Post Office Protocol - Version 3), IMAP(Internet Mail Access Protocol), HTTP</strong> 등이 있다.
<br><br><br>
참고: <a href="https://www.amazon.com/Computer-Networking-Top-Down-Approach-7th/dp/0133594149" rel="external nofollow noopener noreferrer" target="_blank">Computer Networking - A Top-Down approach</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">이전</a></div><div class="pagination-next"><a href="/page/2/">다음</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/tk-one-profile.jpeg" alt="TK-one"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">TK-one</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Seoul, South Korea</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">12</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/TK-one/" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/TK-one/"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/maven/"><span class="level-start"><span class="level-item">maven</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/network/"><span class="level-start"><span class="level-item">network</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/nodejs/"><span class="level-start"><span class="level-item">nodejs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/personal/"><span class="level-start"><span class="level-item">personal</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/tool/"><span class="level-start"><span class="level-item">tool</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0/"><span class="level-start"><span class="level-item">컴퓨터구조</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-07T13:21:13.000Z">2022-03-07</time></p><p class="title"><a href="/2022/03/07/coronavirus-confirmed/">코로나 확진후기</a></p><p class="categories"><a href="/categories/personal/">personal</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-05T12:59:06.000Z">2022-03-05</time></p><p class="title"><a href="/2022/03/05/how-to-use-markdown/">마크다운(Markdown) 사용법</a></p><p class="categories"><a href="/categories/tool/">tool</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-07T16:51:46.000Z">2020-09-08</time></p><p class="title"><a href="/2020/09/08/file-system-design/">파일시스템 5편 - 파일시스템 디자인-2</a></p><p class="categories"><a href="/categories/OS/">OS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-07T15:51:46.000Z">2020-09-08</time></p><p class="title"><a href="/2020/09/08/file-system-design-1/">파일시스템 4편 - 파일시스템 디자인-1</a></p><p class="categories"><a href="/categories/OS/">OS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-07T07:14:20.000Z">2020-09-07</time></p><p class="title"><a href="/2020/09/07/file-system-concept/">파일시스템 3편 - 파일시스템이란?</a></p><p class="categories"><a href="/categories/OS/">OS</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">3월 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">9월 2020</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">3월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">1월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">8월 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">7월 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">2월 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">8월 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/coronavirus/"><span class="tag">coronavirus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/covid19/"><span class="tag">covid19</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/event-loop/"><span class="tag">event-loop</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/markdown/"><span class="tag">markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/maven/"><span class="tag">maven</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nodejs/"><span class="tag">nodejs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/smtp/"><span class="tag">smtp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/thread/"><span class="tag">thread</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0/"><span class="tag">컴퓨터구조</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C/"><span class="tag">파일시스템</span><span class="tag">6</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">업데이트 소식 받기</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="구독"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="기술블로그" height="28"></a><p class="is-size-7"><span>&copy; 2023 TK-one</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv">0</span>명의 사용자가 방문 함</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>