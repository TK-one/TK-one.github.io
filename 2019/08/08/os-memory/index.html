<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>운영체제 9편 - 메모리 - 기술블로그</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="기술블로그"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="기술블로그"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="이 글은 학부 운영체제 수업을 듣고 정리한 글입니다.맥락없이 운영체제에 대한 내용들이 불쑥 등장하니 양해부탁드립니다.   이번 편은 메모리에 대한 내용입니다."><meta property="og:type" content="blog"><meta property="og:title" content="운영체제 9편 - 메모리"><meta property="og:url" content="https://tk-one.github.io/2019/08/08/os-memory/"><meta property="og:site_name" content="기술블로그"><meta property="og:description" content="이 글은 학부 운영체제 수업을 듣고 정리한 글입니다.맥락없이 운영체제에 대한 내용들이 불쑥 등장하니 양해부탁드립니다.   이번 편은 메모리에 대한 내용입니다."><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://tk-one.github.io/images/logical-address-creation.png"><meta property="og:image" content="https://tk-one.github.io/images/address-translation-old.png"><meta property="og:image" content="https://tk-one.github.io/images/address-translation.png"><meta property="og:image" content="https://tk-one.github.io/images/mmu.png"><meta property="og:image" content="https://tk-one.github.io/images/virtual-address-mapping.png"><meta property="og:image" content="https://tk-one.github.io/images/paging-model.png"><meta property="og:image" content="https://tk-one.github.io/images/page-table-translation.png"><meta property="og:image" content="https://tk-one.github.io/images/tlb-paging.png"><meta property="og:image" content="https://tk-one.github.io/images/2-level-page-table-example.png"><meta property="og:image" content="https://tk-one.github.io/images/2-level-page-mapping.png"><meta property="og:image" content="https://tk-one.github.io/images/page-walk.png"><meta property="og:image" content="https://tk-one.github.io/images/inverted-paging.png"><meta property="og:image" content="https://tk-one.github.io/images/demand-paging.png"><meta property="og:image" content="https://tk-one.github.io/images/page-fault-handler.png"><meta property="og:image" content="https://tk-one.github.io/images/page-replacement.png"><meta property="og:image" content="https://tk-one.github.io/images/swapping.png"><meta property="og:image" content="https://tk-one.github.io/images/kernel-memory.png"><meta property="article:published_time" content="2019-08-08T14:07:51.000Z"><meta property="article:modified_time" content="2023-06-07T16:19:22.350Z"><meta property="article:author" content="TK-one"><meta property="article:tag" content="OS"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://tk-one.github.io/images/logical-address-creation.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tk-one.github.io/2019/08/08/os-memory/"},"headline":"운영체제 9편 - 메모리","image":["https://tk-one.github.io/images/logical-address-creation.png","https://tk-one.github.io/images/address-translation-old.png","https://tk-one.github.io/images/address-translation.png","https://tk-one.github.io/images/mmu.png","https://tk-one.github.io/images/virtual-address-mapping.png","https://tk-one.github.io/images/paging-model.png","https://tk-one.github.io/images/page-table-translation.png","https://tk-one.github.io/images/tlb-paging.png","https://tk-one.github.io/images/2-level-page-table-example.png","https://tk-one.github.io/images/2-level-page-mapping.png","https://tk-one.github.io/images/page-walk.png","https://tk-one.github.io/images/inverted-paging.png","https://tk-one.github.io/images/demand-paging.png","https://tk-one.github.io/images/page-fault-handler.png","https://tk-one.github.io/images/page-replacement.png","https://tk-one.github.io/images/swapping.png","https://tk-one.github.io/images/kernel-memory.png"],"datePublished":"2019-08-08T14:07:51.000Z","dateModified":"2023-06-07T16:19:22.350Z","author":{"@type":"Person","name":"TK-one"},"publisher":{"@type":"Organization","name":"기술블로그","logo":{"@type":"ImageObject","url":"https://tk-one.github.io/img/logo.svg"}},"description":"이 글은 학부 운영체제 수업을 듣고 정리한 글입니다.맥락없이 운영체제에 대한 내용들이 불쑥 등장하니 양해부탁드립니다.   이번 편은 메모리에 대한 내용입니다."}</script><link rel="canonical" href="https://tk-one.github.io/2019/08/08/os-memory/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/androidstudio.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-124797892-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-124797892-1');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/rss2.xml" title="기술블로그" type="application/rss+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="기술블로그" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-08-08T14:07:51.000Z" title="08/08/2019, 23:07:51">2019-08-08</time>&nbsp;게시 됨</span><span class="level-item"><a class="link-muted" href="/categories/OS/">OS</a></span><span class="level-item">한 시간안에 읽기 (약 9389 단어)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>회 방문</span></div></div><h1 class="title is-3 is-size-4-mobile">운영체제 9편 - 메모리</h1><div class="content"><p>이 글은 학부 운영체제 수업을 듣고 정리한 글입니다.<br>맥락없이 운영체제에 대한 내용들이 불쑥 등장하니 양해부탁드립니다.  </p>
<p>이번 편은 메모리에 대한 내용입니다.  </p>
<span id="more"></span>

<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>우리 핸드폰에서 가장 비싼 부품이 무엇일까? 첫번째는 CPU, 두번째로는 LCD 패널, 그 다음이 메모리다. CPU는 가장 비싸다. 이를 놀게만들수는 없다. 결국 범용 컴퓨터의 목적은 CPU 활용률(utilization)을 극대화 하는게 중요하다.  </p>
<p>이전의 작성한 운영체제편들에서 사용자에게 빠른 응답을 제공하기위한 멀티프로그래밍도 알아보았고 이를 위해 스케줄링하는 것도 알게되었다. 여러 프로그램이 concurrent하게 돌아가다 보니 동기화 라는 것도 알게되었다.  </p>
<p>하지만 여러 프로그램이 동시에 메모리에 적재되어 실행되면서 메모리를 공유해야할 필요성이 생겼다. 메모리가 아무리 커진다고 하더라도 메모리관리는 필요하다. 여러개의 프로세스가 동시에 뜰 수 있기 때문이다. 어떻게 이를 관리할 수 있을까?  </p>
<h2 id="주소공간-Address-space"><a href="#주소공간-Address-space" class="headerlink" title="주소공간(Address space)"></a>주소공간(Address space)</h2><p>주소공간은 프로세스에서 참조할 수 있는 주소들의 범위이다. 주소공간은 프로세스와 1대1로 매핑되며 스레드들은 이를 공유한다.  </p>
<p>주소공간의 크기는 CPU의 address bus에 의존한다. <a href="/2019/08/09/system-bus/">Address Bus에 대해 다룬 글</a>이 있으니 참고하면 좋겠다.  </p>
<p>예를들어 address bus가 32bit width이면 주소자체의 개수는 2<sup>32</sup>개 있고 byte-addressable 이면 주소공간의 크기는 4GB가 되겠다. 만약 word-addressable이고 word가 16bit이면 주소공간의 크기는 8GB가 된다.<br>byte-addressable 이라는 것은 최소로 읽어낼 수 있는 단위가 byte인 것이다. 즉 모든 byte 단위들로 주소를 가지고 있는 것이다.<br>word-addressable이고 word가 16bit이라면 char 타입을 저장할때 나머지 8bit는 비어있게된다. 이런면에서 memory 효율화 차이가 있지만 이런 내용들은 컴파일러가 적절하게 최적화할 수 있다.<br>요즘은 프로세서들은 byte-addressable 하지않다. 대부분 work-addressable 하므로 한번 읽으면 4byte를 한번에 읽는다.  </p>
<p>또 메모리는 Memory alignment 라고하여, 메모리 주소로 접근할 때 word size에 대해서 align하는 것으로 제한한다. 즉 word size가 4byte이고 byte-addressable이라면 메모리 주소로 접근할때 반드시 4의 배수로 접근해야 한다는 것이다. 그렇지 않으면 trap이 발생한다. </p>
<h2 id="물리주소와-가상주소"><a href="#물리주소와-가상주소" class="headerlink" title="물리주소와 가상주소"></a>물리주소와 가상주소</h2><p>물리주소라는 것은 메모리를 접근할 때 사용되는 주소다. Address Bus로 메모리에 주소가 들어갈때는 다 물리주소로 들어간다. 메모리 자체는 수동적인 device이다. 주소가 들어오면 그냥 주소를 읽어들이는 것 뿐이다.<br>가상주소는 프로세스 관점에서 사용하는 주소이다. 우리가 이미 사용하고 있는 변수접근도 이미 가상주소를 사용하여 접근하고 있다. Logical한 주소공간이기 때문에 주소공간을 의미있는 단위로 나누어 사용할 수 있다.<br>이전에 다루었던 내용에서 프로세스의 메모리구조를 보았을때 text segment, data segment, stack 등으로 공간을 나누었었다. 이들은 가상주소를 의미있는 단위로 나누어 사용한 것 뿐이다.  </p>
<h4 id="Compile-amp-Link-time에서의-주소"><a href="#Compile-amp-Link-time에서의-주소" class="headerlink" title="Compile &amp; Link time에서의 주소"></a>Compile &amp; Link time에서의 주소</h4><p>Compile과 linking에서 다양한 논리주소들이 생성된다. Compiler는 symbol table을 만드는 것이 핵심이다. 예를 들면, 프로그래머들은 변수로 전부 이해할 수 있는 이름을 사용한다. int a, b에서 a, b 모두 symbol이다. 각 symbol이 가리키고 있는 메모리 주소를 map으로 가지고있는게 symbol table이다.<br>다만 이 symbol table에서의 주소는 relative한 주소이다. 오직 Object file 안에서만 유효한 주소이다. 주소는 0부터 시작하고 이후 relocate할 수 있다. 상대적인 위치만 정해놓은 것이다.<br>Linking을 하게되면 하나의 바이너리가 만들어진다. Linker가 하는것은 address resolution이다. 앞에서 만들어낸 relative한 주소를 relative하지 않게 만든다. 모든 Object 파일들과 라이브러리들을 묶어서 symbol table에 의존적이지 않은 주소를 만들어 낸다. 주소를 0부터 쫙 매긴다. 각각 들어가는 모듈들을 시작하는 주소에 상대적으로 다 더해줘서 주소를 모두 만들어낸다. 여기서 만들어지는게 가상주소이다. 이것이 프로그램이 사용하는 주소가 된다.<br>프로그램의 수행을 위해 Loader는 executable을 메모리로 load 한다. 
메모리에 올라가면 그때 또 프로그램이 가지고있는 주소와 물리주소간에 연결을 시켜주어야 한다. 이를 위해 binding을 한다. 프로그램이 가지고 있는 주소와 물리주소를 연결시킨다.<br>Load가 다시 진행되면 똑같은 executable이 다른 물리주소로 가게될 수 있다. 그리고 런타임시에도 밑에서 자세히 보겠지만 swapping과 paging을 통해 물리메모리에서 내려갔다가 올라갈때 주소가 바뀔 수 있다.  </p>
<p align="center">
    <img style="max-width: 400px" alt="다양한 논리주소의 생성" src="/images/logical-address-creation.png"/>
</p>

<p>이야기가 길어졌는데 결국 하고자 하는 이야기는 Compile time, Link time, load 과정에서의 주소와, runtime 할때의 주소가 따로 있다는 것이다. General purpose 한 운영체제에서는 보통 이런방법을 사용한다.  </p>
<h2 id="초창기-컴퓨터에서의-주소관리"><a href="#초창기-컴퓨터에서의-주소관리" class="headerlink" title="초창기 컴퓨터에서의 주소관리"></a>초창기 컴퓨터에서의 주소관리</h2><p>초기의 시스템에서는 아주 간단한 주소변환만 했다.<br>주소에 base register에 있는 값을 더한다. 그리고 이 값을 바로 물리주소로 사용했다. base register를 프로그램마다 바꾸어 주는 방식이다. 즉, 각 시작번지를 바꾸는 방법이다.  </p>
<p align="center">
    <img alt="초창기 시스템의 주소변환" src="/images/address-translation-old.png"/>
</p>

<p>이렇게 하는방법은 오버헤드가 적었다. 그냥 base register에 더하기만 하면 되었다. 다만 약점도 명확했는데, 프로세스가 반드시 continuous 해야 동작했다. 즉 한덩어리로 연결이 되어있어야 한다. linear 해야한다는 의미이다.<br>이를 극복하기 위해 virtual memory개념을 만들고 이를 translation을 하는 방법을 생각해냈다. 지금은 전부 이런 memory translation 을 전제로 하고있다. 가상주소를 변환하고 그것을 가지고 물리메모리에 접근한다.<br>리눅스 Kernel이 virtual translation과 physical memory 주소로의 변환을 모두 다룬다.  </p>
<p align="center">
    <img alt="주소변환" src="/images/address-translation.png"/>
</p>

<p>여기에 DMA가 붙으면 어디에 붙어야할까?<br>DMA는 I&#x2F;O를 대신해준다. I&#x2F;O 데이터를 읽어온 것을 메모리에 써주고, 또는 I&#x2F;O에 쓸 것을 메모리에서 가져와서 대신 write 해준다.<br>DMA를 위 그림에 넣으려한다. DMA가 받아들이는 주소는 Virtual Address일까 Physical Address일까?<br>보통은 DMA는 Physical Address를 받는다. DMA중에 Virtual 주소를 받는것도 있긴하다. 이를 DVMA라고 부른다. 다만 일반적인 General purpose PC에서의 DMA에서는 물리주소를 받는다.  </p>
<h2 id="MMU-Memory-Management-Unit"><a href="#MMU-Memory-Management-Unit" class="headerlink" title="MMU(Memory Management Unit)"></a>MMU(Memory Management Unit)</h2><p>위에서 virtual address를 physical address로 변환하기 위해서는 translation을 해야한다고 했다. 다만 이 translation 속도가 굉장히 중요하다. 잘못하면 memory 접근속도가 반으로 떨어질 수 있다. 이 성능을 높이기 위해서는 software로는 더이상은 한계가 있다는 것을 알고 하드웨어를 도입했다. 이것이 MMU(Memory Management Unit)이다.<br>CPU는 그냥 주소를 MMU에 보낸다. MMU는 이를 physical address로 변환한다.<br>MMU는 CPU 칩안에 붙어있으며, address bus에는 physical address가 실린다.  </p>
<p align="center">
    <img alt="MMU" src="/images/mmu.png"/>
</p>

<p>위의 구조에서 CPU 캐시는 어디에 위치할까? 캐시는 translation 하기 전에 작동한다. 그 이유는 캐시는 빨리 접근하는 것이 중요하다. 캐시 hit이 되면 이를 translate 할 필요가 없으므로 더 빠르게 값을 얻을 수 있다. 즉 캐시는 virtual address를 보고있다. 다만 virtual address는 그 유효범위가 프로세스에서만 유효하다. Context Switching이 일어나면 캐시를 전부 flush 시켜야 한다. virtual address 이기 때문에 서로 다른 프로세스가 virtual address가 같지만 physical address는 다를 수 있기
때문이다. 다만 또 어떤 디자인에서는 캐시를 physical address에 붙이는 것도 존재하여 항상 그런것은 아니다.<br>이 CPU 캐시는 Kernel이 flush 해주어야 한다. 이를 flush할 수 있는 instruction이 존재한다. 다만 이 또한 연구가 계속 되고있으므로 언제든 변할 수 있다.  </p>
<h2 id="가상메모리-Virtual-Memory"><a href="#가상메모리-Virtual-Memory" class="headerlink" title="가상메모리(Virtual Memory)"></a>가상메모리(Virtual Memory)</h2><p>가상메모리는 실제로 존재하지 않지만 사용자에게 메모리로서 역할을 한다. 가상 메모리를 생각한 아이디어는 다음과 같다.<br>물리메모리를 가지고 어떻게 이를 관리할 것인가에 대해 초점이 맞추는게 아닌, virtual memory가 있다고 가정을 하고 사용자들에게 그냥 virtual memory를 가지고 마음껏 사용할 수 있도록 하자는 것이 핵심이다.<br>프로세스가 수행되기 위해서 프로그램의 모든 부분이 물리메모리에 있을 필요가 없다는 것이다. 결국 프로세스는 현재 실행하고있는 code&#x2F;data&#x2F;stack 부분만 물리메모리에 있으면 실행가능하다.  </p>
<h4 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h4><p>메모리 주소공간을 동일한 크기인 page 라는 단위로 나누어 관리한다. 이를 <strong>Paging</strong> 이라고 한다.<br>보통 1 page의 크기를 4KB로 한다. 보통 Page Frame이라고 하면 물리메모리를 고정된 크기로 나누었을때 하나의 블록을 의미한다. Page 라고 하면 보통 가상메모리의 블록을 의미한다. Frame과 Page의 크기는 동일하다. 이 둘을 잘 구분해서 이해할 수 있도록 하자. </p>
<p>Page가 하나의 Frame을 할당받으면 물리메모리에 위치하게 된다. Frame을 할당받지 못한 Page들은 외부 저장장치(Backing Store)에 저장된다. Backing Store도 Page, Frame과 같은 크기로 나누어져 있다.  </p>
<p>CPU가 관리하는 모든 주소는 두 부분으로 나뉜다. page 번호와 page offset이다.<br>page 번호는 각 프로세스가 가진 페이지 각각에 앞에서 부터 부여된 번호이다. 예를들어 1번 프로세스는 0부터 63번까지의 페이지를 가지고 있다.<br>Page offset은 각 페이지 안에서의 내부주소를 가리킨다. offset은 page가 4KB이니 0부터 4095까지 존재한다.<br>Page 번호와 offset으로 모든 주소를 표현할 수 있다. 예를들어 1번 프로세스의 12번 페이지(page 번호)의 34번째(offset) 데이터로 표현할 수 있다.  </p>
<p>잘 이해했는지 확인하기 위해 퀴즈를 풀어보자.  </p>
<ol>
<li>128MB의 물리메모리를 4KB 단위로 페이징하려면 몇개의 frame이 필요할까?  </li>
<li>4GB의 logical address를 페이징하려고 하면 총 몇개의 page가 필요한가? (페이지 크기는 4KB)  </li>
<li>page 크기가 4KB일때, 한 페이지의 메모리를 access 하기 위한 주소 bit는 몇 bit인가?</li>
</ol>
<p>해답은 다음과 같다.  </p>
<ol>
<li>2<sup>27</sup> &#x2F; 2<sup>12</sup> &#x3D; 2<sup>15</sup>개 (약 32,000개)  </li>
<li>2<sup>32</sup> &#x2F; 2<sup>12</sup> &#x3D; 2<sup>20</sup>개 (약 1,000,000개)</li>
<li>4KB 크기이므로 12bit이다.</li>
</ol>
<h4 id="가상메모리-mapping"><a href="#가상메모리-mapping" class="headerlink" title="가상메모리 mapping"></a>가상메모리 mapping</h4><p align="center">
    <img alt="가상메모리 mapping" src="/images/virtual-address-mapping.png"/>
</p>

<p>실제 물리 메모리에는 이렇게 그림처럼 올라간다. 어떤 조합으로 올라갈것인가는 운영체제의 몫이다.<br>예를들면 위 그림에서 P3에 있는 page를 하나 더 물리메모리에 올리고싶다고 하자. 근데 현재는 물리메모리가 모두 사용중이다. 새로운 page를 올리기 위해 이미 올라가있던 Frame을 빼서 외부 저장장치에 임시로 저장해놓는다. 나중에 이 Page가 다시 필요하면 다시 가져와서 다시 메모리에 넣는다. 그리고 이를 반복한다.  </p>
<p>서로 다른시간 t1, t2가 있다고 했을때 동일한 page frame에 대하여 t1과 t2에 특정 page frame에는 서로 다른 virtual page가 올라갈 수 있다.</p>
<h2 id="Page-Table"><a href="#Page-Table" class="headerlink" title="Page Table"></a>Page Table</h2><p>Page Table은 virtual memory와 physical memory 사이의 매핑이다. 각 프로세스의 페이지 정보를 저장한다. 그러므로 프로세스마다 하나의 page table을 가진다.<br>테이블의 인덱스는 페이지 번호이다. table 내용으로는 물리 frame의 시작주소가 있다. 이 시작주소와 페이지 offset을 결합하여 원하는 데이터가 있는 물리 메모리 주소를 알 수 있다.<br>page 크기가 4KB이면 offset이 12bit이므로 <code>page(20 bit) + offset(12 bit)</code>가 된다.<br>그러므로 물리 frame 번호만 변환하고 뒤에 offset을 붙이면 물리메모리 주소를 알 수 있다.  </p>
<p align="center">
    <img alt="가상메모리와 물리메모리 사이의 paging 모델" src="/images/paging-model.png"/>
</p>

<p>Page table은 Kernel이 관리하고 있는 data structure이다. Page table은 물리메모리 상에 저장이 되어있다. Page-table base register가 현재 수행중인 프로세스의 물리메모리 내 page table의 위치를 가리키고 있다. Context Switching이 일어나면 이 register의 값을 PCB에 저장한다. page table의 위치를 저장하는 것이다. 새로운 프로세스가 스케줄링되면 Kernel이 register의 값을 변경해주어야 한다.  </p>
<p>결국 이를 위해서는 Kernel이 프로세스의 page table 위치를 알고있어야하는데, Page Table은 프로세스가 맨 처음 만들어질때 생성된다.  </p>
<p align="center">
    <img alt="Page table을 이용한 주소변환" src="/images/page-table-translation.png"/>
</p>

<p>그림의 p는 페이지의 인덱스이며 page 번호이다. 이 page가 매핑된 값을 앞에 20bit에 넣고 offset은 그대로 뒤에 붙여준다. 그러면 정확한 물리메모리의 address가 나온다.<br>이 작업을 MMU가 한다. MMU는 하드웨어이다. 왜 이걸 MMU가 할까?<br>page table은 Kernel data structure로 memory에 있다. memory에 있다는 것은 page table에 접근할때 memory 접근 후, 이를 읽어낸 후 다시 이를 보고 physical 주소로 변환해야한다. 그러면 메모리 접근을 10번하려면 20번을 메모리 접근해야한다. 당연 성능이 좋지않다. 그래서 이를 하드웨어로 하자는 이야기로 MMU를 사용한다. MMU는 밑에서 다시 볼 것이다.  </p>
<h2 id="Page-Table-Entry"><a href="#Page-Table-Entry" class="headerlink" title="Page Table Entry"></a>Page Table Entry</h2><p>page table 내부를 살펴보자. page table을 통해서 메모리 접근이 다 일어나므로 매우 중요하다. page 별로 메모리에 올리고 내리고 하는게 가능하다. 이를 위해 page table이 어떻게 구현되어있는지가 핵심적이다.<br>Page Table Entry란 Page table에 있는 하나의 record-page를 의미한다. 간단하게 PTE라고 한다. PTE는 page에 대한 접근이 있었는지, 사용이 되는지의 여부, page가 바뀌었는지의 여부를 저장할 수 있다.<br>PTE의 대략적인 필드내용은 다음과 같다.  </p>
<ul>
<li><strong>Page base Address</strong><br>해당 페이지에 할당된 프레임의 시작주소이다. 이를 통해 물리메모리에 접근할 수 있다.  </li>
<li><strong>Flag bits</strong><br>Accessed bit: 페이지에 대한 접근이 있었는지에 대한 bit<br>Dirty bit: 페이지 내용의 변경이 있었는지에 대한 bit<br>Present bit: 현재 페이지에 할당된 Frame이 있는지에 대한 bit<br>Read&#x2F;Write bit: 읽기&#x2F;쓰기에 대한 권한표시 bit</li>
</ul>
<p>실제로 프로세스가 작업하는 페이지는 물리메모리에 없을 수 있다. 이를 해결하기 위해 Present bit이 필요하다.<br>Dirty bit은 밑에서 볼 내용이지만 page가 page-out 되고, 다시 frame을 할당받았을때 dirty bit가 마킹이 안되어있으면 이전과 같은내용으로 다시 page-out이 될 때 I&#x2F;O로 다시 써줄 필요가 없으므로 성능상 이득을 볼 수 있다.  </p>
<p>Segmentaion fault의 발생은 언제 일어날까? 예를들어 <code>*p = 1</code>의 코드가 있는데 p가 NULL, 즉 0인 경우에 발생한다. 프로세스가 만들어 질때 첫번째 page는 읽어서도 안되고 써서도 안된다고 표시를 한다. 정확히는 fork 할때 page table도 copy를 하므로 똑같이 page 0번의 PTE에 Read&#x2F;Write bit을 마킹을 해준다. 그래서 NULL pointer에 접근할때 0번의 PTE에 접근시 trap이 발생하여 segmentation fault가 발생한다.  </p>
<p>이 Page table과 PTE를 보면 예전 프로세스에서 말했던 프로세스는 protection domain이라는 것을 이해할 수 있다. 프로세스 A는 프로세스 B의 page table에 접근할 수 없기 때문이다. 이는 MMU가 접근을 시켜주지 않는다. 다른 프로세스의 메모리에 접근할 수 없다는 것에 대해 이런 배경이 숨겨져 있다.  </p>
<h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2><p>Computer Science의 magic 2가지가 있다. 하나는 caching이고 또 하나는 indirection이다.<br>성능이 안나오면 caching을 하는 경우가 많다. 그리고 뭐든지 복잡하면 layering을 한다. 그러므로 항상 computer science를 공부할때에는 여기서는 어떤 indirection을 사용하고 있는지 보면 도움이 될때가 많다.<br>캐싱을 사용하지 않으면 페이징 방법에서는 데이터로의 접근이 항상 두번의 메모리 접근을 거쳐야 한다. Page table에 한번 그리고 물리메모리에 한번이다. 이것이 메모리 접근 속도를 떨어뜨린다.<br>이를 극복하기 위해 MMU도 caching을 사용한다. 이것이 <strong>TLB</strong>(<strong>Translation Look-aside Buffers</strong>)이다.  </p>
<p>Page table을 이용해 변환된 주소를 TLB에 저장해둔다. 그리고 다음 접근시에 TLB에 hit이 된다면 TLB에 저장되어있는 값을 이용하여 빠르게 변환된 주소를 얻는다. TLB는 register이기 때문에 빠른 수행이 가능하다. TLB hit ratio를 높여야 전체적인 메모리 접근속도를 높일 수 있다. miss가 나면 원래처럼 page table을 물리메모리에서 다시 조회해야한다.  </p>
<p>TLB entry는 보통 16개에서 512개 정도이다. 이미 우리가 사용하는 PC들은 모두 MMU가 붙어있다.<br>TLB를 이용한 paging을 그림으로 나타내면 다음과 같다.  </p>
<p align="center">
    <img alt="TLB를 이용한 페이징" src="/images/tlb-paging.png"/>
</p>

  
<h2 id="MultiLevel-Page-Table"><a href="#MultiLevel-Page-Table" class="headerlink" title="MultiLevel Page Table"></a>MultiLevel Page Table</h2><p>Page Table의 크기는 얼마일까? PTE 하나는 보통 4 byte의 크기를 가진다. 그러므로 page table의 크기는 4MB이다. 크기가 작다고 생각할 수 있겠지만 프로세스가 100개라면 400MB가 된다.<br>우리가 만든 프로그램이 있다고 해보자. 이 프로그램에서 사용하는 page의 개수는 몇개일까?<br>segment별로 생각해보자. stack은 보통 프로그램에서 32KB를 넘어가지를 않는다. text segment는 코드가 1만 라인이라면 Page 10개를 넘지 못한다. text segment도 40KB를 넘기기 힘들다는 것이다. data segment도 보통은 작은 크기를 가진다. 결국 우리가 만든 프로그램은 PTE(page table entry)가 100개를 넘는 프로그램을 만들기 힘들다는 것이다.  </p>
<p>Page table의 PTE는 총 2<sup>20</sup>개이다. 약 100만개이다. 그러면 보통 프로그램에서는 이 100만개의 PTE중에 100개를 사용한다는 것은 비율상 0.01%개의 PTE만 사용된다는 것이다. Kernel 메모리 낭비가 굉장히 심하다.  </p>
<p>이를 어떻게 메모리 사용량을 줄일수 있을까 하여 Multi-Level Page Table이 나오게 되었다. Intel은 거의다 2-level page table을 사용한다. page table 자체도 paging된 공간에 저장된다.  </p>
<h4 id="2-Level-Page-Table"><a href="#2-Level-Page-Table" class="headerlink" title="2-Level Page Table"></a>2-Level Page Table</h4><p>Outer page table을 한개 더 두어서 이들이 page table들을 가르키도록 한다. 
여기서 말한 outer page table은 level-1 page table이 된다.<br>예를들어, 20-bit를 차지하고 있는 page number를 다시 아래와 같이 나눈다.<br><code>10-bit page 번호 + 10-bit page 주소</code><br>결국 32bit 주소의 모양은 다음과 같아진다.  </p>
<p align="center">
    <img alt="2-Level Page Table 32bit 주소" src="/images/2-level-page-table-example.png"/>
</p>

<p>그러면 level-1 page table에는 1024개의 entry가 들어간다. 이 각각의 entry가 level-2 page table을 가리키는 구조이다. 이 level-2 page table에도 1024개의 entry가 존재하게 된다.  </p>
<p align="center">
    <img alt="2-Level Page Table 매핑 예시" src="/images/2-level-page-mapping.png"/>
</p>

<p>결국 level-1 page table entry 중 1개가 mapping 하고 있는 virtual memory의 크기는 4MB이다.<br>만약 page table entry의 4개만 사용하고있는 프로세스는 page table에 얼마의 메모리가 필요할까?<br>level-1 page table은 4KB가 필요하고, level-2 page table은 3개를 사용하고 있다고 가정하자. 최대 4개가 사용될 수 있지만, 2개의 page는 동일한 level-2 page table 에 있다고 하자.<br>그러면 총 4개의 page table이 사용되므로 16KB가 필요하다.  </p>
<h4 id="Page-Walk"><a href="#Page-Walk" class="headerlink" title="Page Walk"></a>Page Walk</h4><p>MMU가 page table에 접근하는 것을 <strong>Page Walk</strong>라는 표현을 사용한다(Table Walk라고도 부른다). 처음에 outer page table을 보고 그리고 level-2 page table을 보고 그 다음 물리메모리 주소를 찾는다. 다음은 2-Level page table 에서의 page walk 예시다.  </p>
<p align="center">
    <img alt="2-Level Page Walk" src="/images/page-walk.png"/>
</p>

<p>page walk는 모든 메모리에 접근할때마다 발생한다.<br>만약 3-Level page table을 도입하면 어떻게될까? 이는 page size들을 더 줄일 수 있겠지만 그만큼 성능에 대한 tradeoff가 존재한다. page walk가 더 길어지기 때문이다.<br>보통 시스템은 2-level 까지만 하는 경우가 많은데 이는 3-level 부터는 성능이 개선되는게 별로 크지 않기때문이라고 한다.  </p>
<h2 id="Inverted-Page"><a href="#Inverted-Page" class="headerlink" title="Inverted Page"></a>Inverted Page</h2><p>64bit 주소공간을 가진 시스템에서는 multi-level paging을 위한 정보의 크기는 32bit에 비해 현격하게 증가되어 문제가 있었다. 그래서 새로 연구된 paging 방법이 있는데 이것이 이번에 소개할 Inverted Page이다. 다만 이 방법은 현재는 거의 사용되고 있지는 않으므로 참고하는 정도로만 보면 좋겠다.  </p>
<p>64bit 주소공간에 모든 물리메모리가 매핑되어 있지는 않지만, 이의 반대로 모든 물리메모리는 가상메모리에 전부 매핑이 되어있을 확률이 높다는 것에서 출발한다.<br>원래는 page table이 virtual page 번호가 들어오면 이에 매핑되는 physical page 번호를 반환하는 거였다면 이를 반대로 physical page 번호가 들어오면 virtual page 번호를 반환하자는 것이 아이디어다.<br>결국 physical page 번호를 가지고 page table을 만드는 것이다.<br>page table entry로는 process id와 virtual page 번호를 넣는다. 즉 pid와 virtual address의 조합으로 page id를 만든다.  </p>
<p align="center">
    <img alt="Inverted Paging" src="/images/inverted-paging.png"/>
</p>

<p>이렇게하면 얻을 수 있는 장점이 시스템 전체에서 하나의 page table만 사용하면 된다.<br>문제는 page table을 검사하는데 너무 오랜 시간이 걸렸다. 테이블 검색을 전체를 검색하지말고 Hash table을 사용하여 개선하기도 하지만 이또한 한계가 존재한다.<br>그러하여 이런 방식보다는 virtual page를 찾고 TLB와 함께 사용하여 성능을 개선한 기존 방식을 많이 사용한다.  </p>
<h2 id="Demand-Paging"><a href="#Demand-Paging" class="headerlink" title="Demand Paging"></a>Demand Paging</h2><p>Demand Paging은 프로세스의 실행을 위한 모든 page를 메모리에 올리지 않고, 필요한 page의 요청이 발생할 때 메모리에 올리는 paging 기법이다.<br>PTE의 valid bit을 활용하여 한 프로세스에 필요한 page를 memory와 secondary storage 간에 이동을 시킨다. 이런 방법을 통해 물리메모리 구성의 시간이 줄어든다. 그리고 프로세스 전체 이미지를 메모리에 올리지 않기때문에 실제 필요한 물리메모리의 양을 줄일 수 있다.   </p>
<p>page table에서 참조하려는 page가 valid한 경우에는 이 page가 실제 물리메모리에 frame이 할당되어 있기 때문에 정상적인 참조가 가능하다. 다만 참조하려는 page가 invalid하다면 이 page가 실제 물리메모리에 존재하지 않으므로 이에 대한 처리가 필요한데 이것을 <strong>Page Fault</strong>라고 한다.  </p>
<p align="center">
    <img alt="Demand Paging" src="/images/demand-paging.png"/>
</p>

  
<h2 id="Page-Fault"><a href="#Page-Fault" class="headerlink" title="Page Fault"></a>Page Fault</h2><p>프로세스가 page를 참조하였을때 해당 page가 할당받은 frame이 없을경우 page fault가 발생한다. 그러면 page fault handler를 수행한다.<br>page fault handler는 새로운 page frame을 할당받는다. 그리고 backing store에서 해당 page의 내용을 frame에 불러들인다. 그리고 page table을 재구성한 후 프로세스의 작업을 재개한다.<br>다음 그림을 보자.  </p>
<p align="center">
    <img alt="Page Fault Handler" src="/images/page-fault-handler.png"/>
</p>

<p>위 그림의 1번에서 페이지 참조를 하면 page fault가 일어난다. page fault는 trap이다.<br>그러면 disk로 부터 해당 page를 읽고 이를 물리메모리에 할당한다. page table을 적절하게 마킹을 표시해주고 재개한다.  </p>
<p>프로세스가 맨 처음 실행될때는 어떤 일이 일어날까?<br>프로세스가 처음 실행을 시작하면 page fault가 일어난다. 처음에는 page가 물리메모리에 frame이 할당되어 있지 않기때문이다. 그래서 맨처음에 제일먼저 page fault가 일어난다.<br>그러면 page fault handler가 disk에서 해당 page의 내용을 다시 frame에 불러오고 이를 재개한다.  </p>
<p>만약에 우리가 local variable을 접근하고 있다고하자. local variable은 stack에 존재한다. 하지만 맨 처음에는 이 접근에 page fault가 발생한다. 그럼 이 또한 disk 에서 읽어와야할까?<br>text segment와 data segment는 disk에서 읽어오는데 stack은 읽어올 내용이 없다. stack은 프로세스가 수행을 시작하고 프로세스가 끝나면 사라져야한다. 그러므로 stack 같은 경우에는 disk에 접근하는 것을 생략하고 frame만 할당한 후 page table을 업데이트하고 수행을 재개한다.  </p>
<p>그러면 맨처음 page fault가 일어날때 어떻게 disk에서 이 위치를 알고 가져올 수 있을까?<br>Loader가 프로그램을 시작할때 executable file을 읽고 disk에 address space를 적절하게 build 해준다. executable file 자체가 text segment와 data segment의 page file이 되도록 하는 시스템도 존재한다.  </p>
<p>page fault는 비싼작업이다. 일단 프로세스는 page fault가 발생하면 멈추어야한다. page fault는 trap으로 동작하고 할당가능한 frame을 찾고 필요하다면 disk에 접근하여 page file을 가져오고 다시 page table을 mapping 해주어야한다. frame을 찾는 것은 micro second 단위이지만 disk 접근은 milli second 단위이다. page fault가 최대한 발생하지 않도록 Kernel에서도 많은 노력을 하고있다.  </p>
<p>프로세스의 실행시간중 page fault를 처리하는 시간이 execution보다 긴 상황을 <strong>Thrashing</strong>이 일어났다고 표현한다. 이런 Thrashing 현상을 줄이기 위해 여러 노력을 하고있는데 그중 하나가 working set model이 있다.  </p>
<h4 id="Working-Set"><a href="#Working-Set" class="headerlink" title="Working Set"></a>Working Set</h4><p>메모리의 Locality 속성을 기반으로 프로세스가 일정시간동안 원활하게 수행되기 위해서 한꺼번에 메모리에 올라와 있어야 하는 page set을 working set이라고 한다. 특정 time window 동안에 접근된 page 들의 집합이 working set에 적용될 수 있다.<br>Kernel은 프로세스의 working set을 계산하여 이를 프로세스에게 제공하여 page fault를 최소화한다. working set에 포함된 page 수는 시스템 전반에 걸쳐 사용가능한 총 page 수에 따라 증가되기도 감소하기도 한다. 또 working set을 프로그램이 시작하면 바로 할당하면서 맨처음 수행시 page fault가 나지않도록 text, data segment에 해당하는 frame을 미리 할당하는 전략도 존재한다.  </p>
<h2 id="Page-Replacement"><a href="#Page-Replacement" class="headerlink" title="Page Replacement"></a>Page Replacement</h2><p>멀티 프로그래밍 시스템에서 user process가 증가하면 모든 user process가 사용하는 page 수보다 물리메모리의 frame이 부족한 상황이 발생할 수 있다. 이럴때에는 page 교체(replacement)를 진행해야 한다. page fault를 할 때 page replacement가 추가된다.<br>물리메모리에 위치한 page를 disk에 저장한다. 그 frame에는 virtual page의 내용이 저장되어 있는데 이 값을 disk에 쓰고, 이 frame에 다른 virtual page를 불러와 교체한다. 이를 <strong>Page Replacement</strong>라고 한다.<br>다음은 page replacement 과정을 간략하게 설명한 내용이다.  </p>
<ol>
<li>Disk에서 요구된 page의 위치를 찾는다.  </li>
<li>물리메모리에서 free frame을 찾는다. 만약 free frame이 있다면 이를 사용하고, 없다면 page replacement 알고리즘을 사용하여 교체할 frame(victim frame)을 선택한다. 교체할 frame을 disk에 저장하고 page table, frame table을 변경한다.  </li>
<li>요구된 page를 free frame으로 읽어들이고 해당 page table, frame table을 적절하게 변경한다.  </li>
<li>user process를 재개한다.</li>
</ol>
<p>비어있는 frame이 존재하지 않는다면 어떤 frame을 교체할지 적절하게 알고리즘으로 판단하여 victim을 정한다. 그리고 이 victim을 disk에 write하고 page table을 변경한다. 이때 invalid bit(present bit)를 설정한다. 이를 page out 되었다고 표현한다.  </p>
<p align="center">
    <img alt="Page Replacement 과정" src="/images/page-replacement.png"/>
</p>

<p>user process가 page out된 page에 다시 접근하면 page fault가 발생한다. 이 말은 physical address binding이 runtime에 일어난다는 증거이다.<br>Kernel은 page fault가 날때마다 page table 업데이트를 2번 해주어야한다. victim은 page out하고 이 victim process의 page table의 invalid bit 세팅하고, 그리고 page-in 된 프로세스의 page table도 수정해야한다.  </p>
<h4 id="Page-Replacement-Algorithms"><a href="#Page-Replacement-Algorithms" class="headerlink" title="Page Replacement Algorithms"></a>Page Replacement Algorithms</h4><p>Page Replacement가 필요할 때 어떻게 교체할 페이지를 고를까?<br>이는 여러 알고리즘이 존재하는데 결국 핵심적인 내용은 이 알고리즘들은 모두 Page Replacement에 의한 I&#x2F;O 작업 수행 횟수를 최대한 줄이려는 목적을 가지고 있으며, 적합한 알고리즘의 사용은 시스템의 성능을 크게 좌우하는 요소이다. I&#x2F;O 작업은 매우 큰 비용을 지불해야 하기 때문이다.  </p>
<p>여러 알고리즘이 존재하고 이들은 매우 간단하게 몇가지만 알아볼 것이다.<br>먼저 가장 목표로 해야되는 것은 앞으로 가장 오랫동안 사용되지 않을 page를 교체해야한다. 그렇게 해야 가장 낮은 page fault 발생빈도를 가질 수 있다. 다만 미래에 어떤 page가 사용되지 않을지는 알수가 없다.  </p>
<h6 id="FIFO-알고리즘"><a href="#FIFO-알고리즘" class="headerlink" title="FIFO 알고리즘"></a>FIFO 알고리즘</h6><p>그냥 먼저 frame이 할당된 page를 교체한다.<br>가장 단순한 알고리즘이며 FIFO 큐를 이용해 구현가능하다.  </p>
<h6 id="NRU-알고리즘"><a href="#NRU-알고리즘" class="headerlink" title="NRU 알고리즘"></a>NRU 알고리즘</h6><p>NRU(Not Recently Used) 알고리즘은 이름 그대로 최근에 사용하지 않은 페이지를 교체하는 방식이다.<br>각 page마다 reference bit와 modified bit를 둔다. 이 bit들의 설정은 MMU가 한다.<br>reference bit는 최초로 frame에 로드되었을때 그리고 참조되었을때 bit를 1로 설정한다. 그리고 주기적으로 0으로 리셋한다.<br>modified bit은 최초로 frame에 로드될때는 0으로 설정하고 이후에 page의 내용이 변경되었을때 1로 설정한다.<br>그래서 page replacement가 필요한 시점에 다음 순서대로 rough 하게 교체대상을 찾는다.  </p>
<ol>
<li>reference bit &#x3D; 0, modified bit &#x3D; 0</li>
<li>reference bit &#x3D; 1, modified bit &#x3D; 0</li>
<li>reference bit &#x3D; 0, modified bit &#x3D; 1</li>
<li>reference bit &#x3D; 1, modified bit &#x3D; 1</li>
</ol>
<h6 id="LRU-알고리즘"><a href="#LRU-알고리즘" class="headerlink" title="LRU 알고리즘"></a>LRU 알고리즘</h6><p>LRU(Least Recently Used) 알고리즘은 가장 오랜시간 참조되지 않은 페이지를 교체하는 방식이다.<br>이는 Page의 locality를 고려하고 가장 이상적인 알고리즘에 근접해있어 가장 많이 사용하는 방법이다.<br>Counter를 사용하여 참조된 시간을 기록하는 방식으로 구현하거나, bit와 Queue를 사용하여 구현한다.  </p>
<h2 id="Swapping"><a href="#Swapping" class="headerlink" title="Swapping"></a>Swapping</h2><p>Page Replacement, Page out은 4KB 짜리 page를 disk로 내보내는 것이다. 하지만 물리메모리가 부족한 상황에서는 page를 하나씩 내보내는 것으로는 부족하다. 이때에는 특정 프로세스 전체를 통째로 내려야한다. 이를 <strong>Swapping</strong>이라고 한다.<br>Swap 대상이 된 프로세스 전체를 secondary storage로 보낸다.<br>이렇게 page out이나 swapping에 사용되는 secondary storage의 영역을 swap 영역이라고 부른다.<br>OS를 설치할때 맨처음 disk에 대해 swap 영역의 크기를 물어보는 부분이 나올때가 있다. 이 부분은 처음에 OS설치시 file system이 이 영역을 사용하지 않고 swap 영역으로 사용하도록 한다.  </p>
<p>서버에서 swap이 발생했다면 이미 상황이 좋지 않은 것이다. 왜냐하면 swap이 발생하면 Thrashing이 발생할 수 밖에 없는데 CPU가 굉장히 바쁘다. 한 프로세스가 사용하는 모든 page들을 disk로 내리고, 다른 프로세스를 swap in 시켜주어야 하기 때문이다.</p>
<p>그러면 이를 방지하기 위해서는 어떻게 해야할까?<br>현실적으로는 물리 메모리의 크기를 늘리거나 프로세스 숫자를 줄여야한다.  </p>
<p>다음은 swapping의 swap-out과 swap-in 과정을 그림으로 표현한 것이다.  </p>
<p align="center">
    <img alt="Swapping" src="/images/swapping.png"/>
</p>

  
<h2 id="Kernel-Memory"><a href="#Kernel-Memory" class="headerlink" title="Kernel Memory"></a>Kernel Memory</h2><p>Kernel Memory 영역은 어떻게 잡히는 것일까? 이또한 위에서 살펴보았던 Virtual Memory와 연관이 있는것일까?<br>시스템이 virtual memory를 사용한다면, Kernel 또한 virtual memory를 사용한다. Windows 같은 경우는 2GB이상을 사용한다. 이는 kernel code, kernel data, process 별 page table 등을 포함하고 이들또한 disk로 page-out 될 수 있다.<br>즉 virtual memory의 특정영역이 Kernel에 사용되도록 되어있다.<br>예를들어 32bit 주소공간을 가진 시스템에서 주소가 2GB 이상부터는 Kernel 영역이라고 정할 수 있다. 그 영역을 매핑하는 page table들은 각 PTE가 kernel page들을 가리키게 된다. 이 PTE들은 user page를 매핑할 수 없다.  </p>
<p>page table은 프로세스마다 존재한다. context switching이 일어나면 바라보는 page table 전체가 변경된다. 하지만 전통적으로 모든 프로세스들이 공유를 하고있는 영역도 존재를 한다.<br>이런 영역같은 경우는 page table에 특별한 marking을 해놓아서 TLB에 캐시가 invalidate 되지 않도록 한다. 그리고 매우 critical 한 부분은 swap이 되지 않도록 설정하기도 한다. 
다음의 virtual memory segment 그림을 보자.  </p>
<p align="center">
    <img style="max-width: 500px" alt="Virtual Memory" src="/images/kernel-memory.png"/>
</p>

<p>Kernel virtual memory 영역은 kernel code와 kernel data를 포함한다.<br>그리고 kernel memory의 특정영역은 physical memory에 매핑이되어 모든 프로세스들이 이를 공유하기도 한다. 예를들어 모든 kernel code와 kernel data는 모든 프로세스들이 공유한다.<br>리눅스 또한 특정영역의 인접한 virtual page들을 인접한 physical page로 매핑하기도 한다. 이는 커널이 physical memory에서 특정 영역을 접근하는데 편하게 해준다.<br>예를들어 page table에 접근을 할때나 memory mapped I&#x2F;O operation을 수행해야 할때 도움을 준다.  </p>
<p>Kernel virtual memory 영역에서 또다른 영역은 프로세스 별로 데이터를 가지고있는 영역도 있는데, 이 영역에는 그 프로세스의 page table이나 그 프로세스의 context에서 실행되는 kernel stack, 다양한 데이터 자료구조들이 존재한다.  </p>
<h4 id="기타사항"><a href="#기타사항" class="headerlink" title="기타사항"></a>기타사항</h4><p>그렇다면 Virtual Memory를 사용하지 않는 운영체제도 있을까?<br>일부 임베디드 시스템들은 virtual meomory를 사용하지 않는 시스템이 있다. 예를들어 자동차 하드웨어의 일부는 virtual memory를 사용하지 않는데 MMU를 사용해야하므로 비용문제등으로 사용하지 않는 경우가 있다.  </p>
<br/>
<br/>
<br/>
<br/>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/OS/">OS</a></div><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-63138b1a1a412ebf" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/08/09/system-bus/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">시스템 버스(System Bus)란?</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/07/25/classic-problem-of-synchronization/"><span class="level-item">운영체제 8편 - 동기화의 고전적인 문제들</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">댓글</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://tk-one.github.io/2019/08/08/os-memory/';
            this.page.identifier = '2019/08/08/os-memory/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'devtkone' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/tk-one-profile.jpeg" alt="TK-one"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">TK-one</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Seoul, South Korea</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">26</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/TK-one/" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/TK-one/"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Hadoop/"><span class="level-start"><span class="level-item">Hadoop</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/maven/"><span class="level-start"><span class="level-item">maven</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/network/"><span class="level-start"><span class="level-item">network</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/nodejs/"><span class="level-start"><span class="level-item">nodejs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/personal/"><span class="level-start"><span class="level-item">personal</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/tool/"><span class="level-start"><span class="level-item">tool</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0/"><span class="level-start"><span class="level-item">컴퓨터구조</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-06-19T13:29:02.000Z">2022-06-19</time></p><p class="title"><a href="/2022/06/19/hadoop-file-based-data-structure/">Hadoop 파일기반 자료구조(SequenceFile, MapFile)</a></p><p class="categories"><a href="/categories/Hadoop/">Hadoop</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-06-18T13:29:02.000Z">2022-06-18</time></p><p class="title"><a href="/2022/06/18/hbase/">HBase 기초</a></p><p class="categories"><a href="/categories/Hadoop/">Hadoop</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-23T13:42:24.000Z">2022-03-23</time></p><p class="title"><a href="/2022/03/23/hadoop-hdfs/">Hadoop HDFS란?</a></p><p class="categories"><a href="/categories/Hadoop/">Hadoop</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-07T13:21:13.000Z">2022-03-07</time></p><p class="title"><a href="/2022/03/07/coronavirus-confirmed/">코로나 확진후기</a></p><p class="categories"><a href="/categories/personal/">personal</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-05T12:59:06.000Z">2022-03-05</time></p><p class="title"><a href="/2022/03/05/how-to-use-markdown/">마크다운(Markdown) 사용법</a></p><p class="categories"><a href="/categories/tool/">tool</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">6월 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">3월 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">9월 2020</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">3월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">1월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">8월 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">7월 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">2월 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">8월 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/coronavirus/"><span class="tag">coronavirus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/covid19/"><span class="tag">covid19</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/event-loop/"><span class="tag">event-loop</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hadoop/"><span class="tag">hadoop</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hbase/"><span class="tag">hbase</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hdfs/"><span class="tag">hdfs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/markdown/"><span class="tag">markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/maven/"><span class="tag">maven</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nodejs/"><span class="tag">nodejs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/smtp/"><span class="tag">smtp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/thread/"><span class="tag">thread</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0/"><span class="tag">컴퓨터구조</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C/"><span class="tag">파일시스템</span><span class="tag">6</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">업데이트 소식 받기</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="구독"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="기술블로그" height="28"></a><p class="is-size-7"><span>&copy; 2023 TK-one</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv">0</span>명의 사용자가 방문 함</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>