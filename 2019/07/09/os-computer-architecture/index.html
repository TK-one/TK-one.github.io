<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>운영체제 3편 - 컴퓨터 구조와 I/O(Interrupt &amp; Trap) - 기술블로그</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="기술블로그"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="기술블로그"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="이 글은 학부 운영체제 수업을 듣고 정리한 글입니다.맥락없이 운영체제에 대한 내용들이 불쑥 등장하니 양해부탁드립니다.   이번에는 운영체제를 이해하기 위한 컴퓨터 구조에 대한 내용이다.Bus, I&amp;#x2F;O 기초를 설명한다."><meta property="og:type" content="blog"><meta property="og:title" content="운영체제 3편 - 컴퓨터 구조와 I/O(Interrupt &amp; Trap)"><meta property="og:url" content="https://tk-one.github.io/2019/07/09/os-computer-architecture/"><meta property="og:site_name" content="기술블로그"><meta property="og:description" content="이 글은 학부 운영체제 수업을 듣고 정리한 글입니다.맥락없이 운영체제에 대한 내용들이 불쑥 등장하니 양해부탁드립니다.   이번에는 운영체제를 이해하기 위한 컴퓨터 구조에 대한 내용이다.Bus, I&amp;#x2F;O 기초를 설명한다."><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://tk-one.github.io/images/single-bus.png"><meta property="og:image" content="https://tk-one.github.io/images/os/prototypical-system-architecture.png"><meta property="og:image" content="https://tk-one.github.io/images/os/modern-system-architecture.png"><meta property="og:image" content="https://tk-one.github.io/images/interrupt-flow.png"><meta property="og:image" content="https://tk-one.github.io/images/trap-flow.png"><meta property="og:image" content="https://tk-one.github.io/images/os/schedule-without-dma.png"><meta property="og:image" content="https://tk-one.github.io/images/os/schedule-with-dma.png"><meta property="og:image" content="https://tk-one.github.io/images/os/filesystem-stack.png"><meta property="article:published_time" content="2019-07-09T08:18:09.000Z"><meta property="article:modified_time" content="2023-06-07T16:17:38.465Z"><meta property="article:author" content="TK-one"><meta property="article:tag" content="OS"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://tk-one.github.io/images/single-bus.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tk-one.github.io/2019/07/09/os-computer-architecture/"},"headline":"운영체제 3편 - 컴퓨터 구조와 I/O(Interrupt & Trap)","image":["https://tk-one.github.io/images/single-bus.png","https://tk-one.github.io/images/os/prototypical-system-architecture.png","https://tk-one.github.io/images/os/modern-system-architecture.png","https://tk-one.github.io/images/interrupt-flow.png","https://tk-one.github.io/images/trap-flow.png","https://tk-one.github.io/images/os/schedule-without-dma.png","https://tk-one.github.io/images/os/schedule-with-dma.png","https://tk-one.github.io/images/os/filesystem-stack.png"],"datePublished":"2019-07-09T08:18:09.000Z","dateModified":"2023-06-07T16:17:38.465Z","author":{"@type":"Person","name":"TK-one"},"publisher":{"@type":"Organization","name":"기술블로그","logo":{"@type":"ImageObject","url":"https://tk-one.github.io/img/logo.svg"}},"description":"이 글은 학부 운영체제 수업을 듣고 정리한 글입니다.맥락없이 운영체제에 대한 내용들이 불쑥 등장하니 양해부탁드립니다.   이번에는 운영체제를 이해하기 위한 컴퓨터 구조에 대한 내용이다.Bus, I&#x2F;O 기초를 설명한다."}</script><link rel="canonical" href="https://tk-one.github.io/2019/07/09/os-computer-architecture/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/androidstudio.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-124797892-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-124797892-1');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/rss2.xml" title="기술블로그" type="application/rss+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="기술블로그" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-07-09T08:18:09.000Z" title="09/07/2019, 17:18:09">2019-07-09</time>&nbsp;게시 됨</span><span class="level-item"><a class="link-muted" href="/categories/OS/">OS</a></span><span class="level-item">44분안에 읽기 (약 6550 단어)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>회 방문</span></div></div><h1 class="title is-3 is-size-4-mobile">운영체제 3편 - 컴퓨터 구조와 I/O(Interrupt &amp; Trap)</h1><div class="content"><p>이 글은 학부 운영체제 수업을 듣고 정리한 글입니다.<br>맥락없이 운영체제에 대한 내용들이 불쑥 등장하니 양해부탁드립니다.  </p>
<p>이번에는 운영체제를 이해하기 위한 컴퓨터 구조에 대한 내용이다.<br>Bus, I&#x2F;O 기초를 설명한다.  </p>
<span id="more"></span>

<h2 id="Bus"><a href="#Bus" class="headerlink" title="Bus"></a>Bus</h2><h4 id="단일-Bus"><a href="#단일-Bus" class="headerlink" title="단일 Bus"></a>단일 Bus</h4><p>초창기에는 Bus가 1개였다. CPU와 Memory가 붙어있는 구조이다.<br>이 방식은 CPU, Memory, I&#x2F;O의 속도가 비슷했던 초창기에 사용했던 모델이다.  </p>
<p align="center">
    <img style="max-width:500px" src="/images/single-bus.png"/>
</p>

<p>그런데 CPU, Device 들은 발전하는 속도가 각각 다르다.<br>1995년도에는 CPU clock이 45MHz였다. 지금은 거의 3.5GHz 정도이다.
속도는 CPU &gt; Memory &gt; IO 속도 순으로 빠를 것이다.<br>1GHz면 명령어 처리에 1 nano second 속도이다. 이와 비교하여 Disk 속도는 ms 단위이다. nano second와 milli second 차이는 100만배 차이이다. 고속도로에서 빠른차와 느린차와 같이 다닐 수 있을까? 불가능하다.<br>이처럼 같은 버스에 연결된 device들 간의 속도차이로 인해 병목현상이 발생한다. 시스템속도는 결국 느린 시스템 속도로 결정이 되게 된다.<br>위처럼 단일 Bus에서 CPU와 Disk를 붙여놓으면 CPU는 대부분 놀고있게 된다.  </p>
<h4 id="계층적-버스구조"><a href="#계층적-버스구조" class="headerlink" title="계층적 버스구조"></a>계층적 버스구조</h4><p align="center">
    <img alt="계층적 버스구조" src="/images/os/prototypical-system-architecture.png"/>
</p>

<p>이를 해결하기 위해 Bus를 나누게 된다.<br>이를 계층적 버스구성이라고 하는데, 접근 빈도가 적고 처리속도가 느린 device들은 System Bus에 직접 연결하지 않고 I&#x2F;O Bus를 거쳐 연결해서 stall 현상을 방지하는 것이다.<br>위 그림을 보게되면 CPU는 Memory와 <strong>Memory Bus</strong>(System Bus)로 연결되어있고, 몇몇 device들은 <strong>General I&#x2F;O Bus</strong>에 연결된다. 현대 시스템에서는 이 general I&#x2F;O bus가 PCI가 될 것이다.<br>높은 성능이 필요한 I&#x2F;O device 들이나 graphic card를 이 general I&#x2F;O bus인 PCI에 연결한다. 더 밑에는 <strong>Peripheral Bus</strong>가 위치하는데 여기에는 SCSI, SATA, USB 등이 속한다. 여기에는 disk, mouse, 키보드 같은 속도가 느린 device들이 연결된다.<br>memory bus는 매우 높은 성능이 필요한데 이처럼 매우 성능이 높은 bus는 비용문제, 난이도 문제로 device를 plug할 수 있는 공간자체를 크게 설계할 수 없다. 따라서 시스템 디자이너들은 이런 계층적 버스구조를 선택했고 I&#x2F;O Bus도 종류에 나누어 높은성능이 필요한 device들은 CPU에 가깝게 배치하였다.<br>Peripheral bus는 조금 느린대신 많은 device들을 배치할 수 있다.  </p>
<h4 id="Modern-시스템-구조"><a href="#Modern-시스템-구조" class="headerlink" title="Modern 시스템 구조"></a>Modern 시스템 구조</h4><p align="center">
    <img alt="Modern 시스템 구조" src="/images/os/modern-system-architecture.png"/>
</p>

<p>요즘에는 점진적으로 특수화한 chipset을 많이 사용하고 있고 성능향상을 위해 point-to-point interconnect를 많이 사용한다.<br>위 그림은 나름 최신?인 2017년에 인텔에서 출시한 Z270 chipset의 대략적인 구조이다.  </p>
<p>CPU는 memory에 가장 가깝게 배치하고 높은 성능이 필요한 graphic card도 가깝게 배치한다.<br>CPU는 I&#x2F;O chip에 Intel이 만든 DMI(Direct Media Interface)를 통해 연결하고 나머지 device들은 이 I&#x2F;O chip에 연결을 한다.<br>I&#x2F;O chip의 오른쪽에는 하드디스크들을 eSATA 인터페이스를 통해 연결하고, 그 밑에는 USB(Universal Serial Bus) 연결로 키보드나 마우스들을 연결할 수 있다.<br>왼쪽에는 PCIe(Peripheral Component Interconnect Express)를 통해 더 높은 성능의 device들이 연결될 수 있다. 이 그림에서는 NIC(Network Interface Card)가 연결되었다.<br>높은 성능이 필요한 NVMe 같은 스토리지 device들도 이곳에 연결되기도 한다.  </p>
<p>이제 I&#x2F;O 기초에 대해 알아보자.  </p>
<br/>

<h2 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h2><p>Interrupt는 비동기적인 이벤트를 처리하기 위한 기법이다. CPU는 외부에서 일어나는 이벤트를 모른다. 그래서 Hardware 적으로 알려주는게 Interrupt이다.<br>예를들어 CPU는 10ms로 time slice를 한다고 할때, 10ms가 경과하는걸 어떻게 알 수 있을까? Timer가 interrupt를 날려준다.<br>또 다른 예로 packet이 도착한다. 그러면 packet을 읽어줘야 하는데, 어떻게 읽을 수 있을까? 패킷이 도착하면 Interrupt를 발생시킨다. 그러면 현재 수행하고 있는 프로그램을 잠시 멈추고 ISR(Interrupt Service Routine)을 수행한다.<br>ISR을 수행하고 다시 멈췄던 곳으로 돌아가 수행을 계속한다.  </p>
<p><strong>Interrupt 처리순서</strong>  </p>
<ol>
<li>현재 state를 저장</li>
<li>ISR(Interrupt Service Routine)으로 점프</li>
<li>ISR 수행</li>
<li>저장한 state를 복원</li>
<li>Interrupt로 중단된 지점부터 다시 시작</li>
</ol>
<p>ISR은 interrupt 종류마다 따로 존재한다. Disk에서 IO block을 읽으면 그에 대한 ISR로 jump 하고, 네트워크 패킷을 읽으면 그에 대한 ISR로 jump 한다.<br>ISR로 jump를 한 후 전부 처리한 후 다시 멈췄던 곳으로 어떻게 다시 돌아가 프로그램 수행을 계속할 수 있을까?<br>이를 위해 ISR로 jump 하기전에 context를 저장을 해야한다. context는 현재 실행 상태를 의미한다.<br>CPU register를 저장해 현재의 state를 저장해야하며, Program Counter 즉 어디까지 수행하다가 멈췄는지를 저장해야한다. ISR 수행을 마치면 저장했던 state를 복구한 후 수행을 계속 이어나간다.<br>인터럽트에는 우선순위가 있다. 이는 Hardware 장치별로 우선순위가 다르게 설정된다.<br>그리고 ISR은 짧아야한다. 너무 길면 다른 Interrupt들이 제 시간에 처리되지 못할수 있다. ISR을 들어갈 때 interrupt를 disable 시킨다. 그렇지 않으면 하염없이 중간에 계속 interrupt가 중첩될 수 있다.</p>
<p>Interrupt flow는 간단하게 다음 그림과 같다.  </p>
<p align="center">
    <img style="max-width:550px" alt="Interrupt flow" src="/images/interrupt-flow.png"/>
</p>

<br/>
  
<h2 id="Trap"><a href="#Trap" class="headerlink" title="Trap"></a>Trap</h2><p>Trap은 Interrupt와 유사하다. Interrupt가 비동기적인 이벤트를 처리하기 위한 기법이였다면 Trap은 동기적인 이벤트를 처리하기 위한 기법이다. 동기적이라는 의미는 현재 수행하고 있는 프로그램에 의해 발생한다는 것이다.<br>Trap은 kernel 안에 있는 Trap handler를 invoke 시키는 event라고 이해하면 쉽다.<br>예를 들어서 divide by zero 하면 멈춘다. divide by zero하면 어떻게 이를 인지할 수 있을까? 바로 Trap 이다. 하드웨어가 divide by zero를 하면 스스로에게 trap을 건다.<br>divide by zero 뿐만 아니라 잘못된 메모리 주소에 접근하려고 하면 segmentation fault가 발생하는데 이때 스스로에게 Trap을 건다.<br>혹은 process가 특별한 instruction을 실행하면 Trap이 발생한다. 이 경우는 보통 system call을 처리하기 위한 Trap이라고 볼 수 있는데, system call은 call의 name과 arguments들을 register나 stack에 저장을 하고 user-initiated한 trap을 발생시킨다.<br>그러면 Trap Handler인 Trap Service Routine을 실행하는데 내부적으로 trap의 타입을 보고 system call에 대한 요청일 경우 call의 name을 보고 그에 맞는 kernel procedure를 호출한다. 그리고 다시 원래의 프로그램 진행을 계속 한다.<br>System call이 trap을 발생시키는 이유는 user mode에서 kernel mode로 변경해야하기 때문이다.  </p>
<p>Interrupt와 다른점은 interrupt는 발생하였을때 context를 전부 다 저장한 후 ISR로 넘어간다. 다만 trap은 따로 context를 저장할 필요가 없다.<br>여기서의 context는 대표적인 예로 register가 있다. Interrupt는 발생했을때 CPU의 register state를 모두 저장하는데 trap은 이들을 저장할 필요가 없다.  .<br>그렇다고 모든 상태를 저장하지 않는다는 이야기는 아니고 trap는 현재의 Program Counter와 stack pointer 등을 하드웨어적으로 자동으로 저장한다. Trap은 무수히 많이 발생하므로 하드웨어적으로 자동으로 저장하도록 처리해놓아 직접 state를 저장할 필요 없고 가볍게 하드웨어적으로만 저장하기 때문에 state를 저장하지 않는다고 표현한다. (TA라는 instruction으로 현재의 stack pointer를 하드웨어적으로 저장하고 수행을 마치고 복구할때는 RTT라는 instruction으로 복구시킨다)<br>사실 조금 더 정확히 말하면 위에서의 Program Counter는 정확히말하면 Kernel mode와 User mode가 각각 서로 따로 PC를 가지기 때문에 따로 저장하지 않는다고 한다. Interrupt Service Routine도 Trap도 모두 kernel mode에서 실행된다.<br>Trap은 짧을 필요는 없다. 시스템 콜을 봐도 수행시간이 긴 시스템 콜도 존재한다. 시스템 콜을 할 때에는 중간에 interrupt를 허용하기도 한다.</p>
<p>간단하게 Trap flow는 다음과 같다.  </p>
<p align="center">
    <img alt="Trap flow" src="/images/trap-flow.png"/>
</p>

<br/>
  
<h2 id="I-x2F-O-Device"><a href="#I-x2F-O-Device" class="headerlink" title="I&#x2F;O Device"></a>I&#x2F;O Device</h2><p>운영체제의 관점에서는 I&#x2F;O Device를 어떻게 바라볼까?<br>일반적으로 하드웨어에는 장치를 제어하는 controller라는게 있다. 이 controller 안에는 대부분 크게 4가지 종류의 register를 가진다.<br><strong>Control(command) register</strong>, <strong>Status register</strong>, <strong>Data register</strong>(<strong>Input register, Output register</strong>) 이다.<br>I&#x2F;O 라는 것은 결국 CPU가 I&#x2F;O Device의 register에 읽고쓰는 동작이라고 이해할 수 있다.<br>Disk에 데이터를 쓴다는 것은 Disk의 control register에 쓰기 명령을 주는 것이다. 그리고 data register에는 어떤 내용을 write할 건지에 대한 정보를 준다.<br>I&#x2F;O하는 과정은 대략적으로 다음과 같다.  </p>
<ol>
<li>Status Register가 BUSY 상태가 아닐때까지 기다린다.</li>
<li>Data register에 값을 쓴다.</li>
<li>Control Register에 command를 쓴다. 그러면 device가 command를 수행을 시작한다.</li>
<li>Device 작업이 끝날때까지 기다려야 하므로 Status Register가 다시 BUSY 상태가 아닐때까지 기다린다.</li>
<li>작업이 끝났으면 Data register를 보면 그 결과에 대한 값이 올라와있다.</li>
</ol>
<p>Data Register는 Input, Output 용을 나누어 Input Register, Output Register로 나누기도 한다.<br>이것이 운영체제가 바라보는 I&#x2F;O Device model 이다.  </p>
<p>여기서의 device register에는 어떻게 접근할까? 보통 이들의 register는 메모리 영역에 mapping을 해놓는다. Memory mapped I&#x2F;O라고도 부르는데 나중에 더 자세히 다루겠지만 매핑된 영역의 주소로 memory read, write instruction만 수행으로 Device Register에 읽고 쓸수있다고 생각하면 쉽다.  </p>
<br/>
  
<h2 id="I-x2F-O-처리기법"><a href="#I-x2F-O-처리기법" class="headerlink" title="I&#x2F;O 처리기법"></a>I&#x2F;O 처리기법</h2><p>만약에 Device에 읽기 요청을 보냈다. 그런데 언제 이 읽기요청이 완료되었는지 모른다. 이를 어떻게 알 수 있을까?<br>CPU는 크게 2가지 방법있다. Polling과 Interrupt이다.  </p>
<h6 id="Polling"><a href="#Polling" class="headerlink" title="Polling"></a>Polling</h6><p>위에서 예시로 본 I&#x2F;O 과정은 CPU가 직접 Device의 Status Register가 준비된 상태인지 확인한다. 그리고 Device 작업이 끝났는지 확인하기 위해 계속해서 Device Status Register를 확인한다. 이 방식이 <strong>Polling</strong> 방식이다.<br>Polling은 loop이나 time-delayed loop에서 특정 이벤트의 도착여부를 계속 확인하는 방식이다.   </p>
<p>Polling을 한 후에는 <strong>PIO</strong>(<strong>programmed I&#x2F;O</strong>)라는 것을 수행한다. 이는 CPU가 직접 I&#x2F;O를 한다. Disk를 read할 때 Disk로 부터 block이 도착했다면 이를 memory로 copy하는 것까지 CPU가 모두 처리해 주어야 한다. 그러면 CPU는 너무 할일이 많고 다른 process를 수행하는 시간도 줄어들게된다.  </p>
<h6 id="Using-Interrupt"><a href="#Using-Interrupt" class="headerlink" title="Using Interrupt"></a>Using Interrupt</h6><p>위의 Polling 방식에서의 CPU 낭비를 줄이기 위해서 Interrupt를 활용할 수 있다. Device를 polling 하는 방식이 아닌, I&#x2F;O를 요청한 process를 sleep하게 하고 CPU는 context switching을 하여 다른 프로세스를 수행한다. Device가 operation 수행을 끝냈으면 hardware interrupt를 발생시키고 CPU는 ISR을 수행하면 해당 I&#x2F;O를 요청한 프로세스를 다시 깨운다. 그리고 다시 스케줄링을 받아 수행을 이어가게 된다.  </p>
<p>얼핏보면 위에서 본 Polling 방식보다는 Interrupt 방식이 훨씬 좋아보인다. 그럼에도 polling이 유리한 상황이 있다.<br>Device에 굉장히 짧은 주기로 빠르게 operation을 해야하는 경우에는 polling이 유리하다.<br>예를들어 화면을 보여주는 display device를 생각해보자.<br>Frame buffer라는 곳이 있는데 이 frame buffer에 frame들을 쓰면 화면에 바로 찍히게 된다. Frame buffer에 계속해서 pixel들을 던지고 refresh 하고 이 일들을 계속 반복한다. 이렇게 빠르게 동작하는 장치는 interrupt로 처리하는 것보다 계속 polling을 하는 것이 효과적이다.<br>이를 Interrupt 방식으로 구현한다면 전체 시스템이 굉장히 느려질 수 있다. 한번 Display Device에 쓸때마다 해당 프로세스는 sleep하고 Context Switching이 일어난다. 그러면 operation이 완료되면 hardware interrupt가 발생하고 해당 프로세스는 다시 ready queue에 들어가 스케줄링을 기다린다.<br>하지만 1초에 60번씩 계속 Device에 써줘야 하는 상황이라면 과도한 Context Switching만 발생할 뿐이다. 이런 경우에는 polling이 유리하다. Interrupt handling과 Context Switching 대한 비용이 polling 비용을 넘어갈 수 있다.<br>Polling 방식과 Interrupt를 합친 하이브리드 방식도 존재한다.  </p>
<br/>
    
<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>위에서 본 Programmed I&#x2F;O 방식은 크기가 큰 data를 device에 전달하기 위해서는 CPU가 많은 작업을 수행해야 한다. 다음 그림은 이런 상황을 묘사한다.  </p>
<p align="center">
    <img style="max-width:600px" src="/images/os/schedule-without-dma.png"/>
</p>
  
<p>프로세스 1 이 수행중이고 disk에 data를 쓰기를 원한다. Interrupt 방식을 사용한다면, 먼저 I&#x2F;O를 하기위해 write하고 싶은 데이터를 메모리로부터 device로 전송해주어야 한다. 정확히는 data register에 이를 copy하여 써주어야한다. 이에 대한 수행시간을 <code>c(copy)</code>로 표현했다.<br>Data copy가 완료되었으면 disk는 I&#x2F;O operation을 수행하고 CPU는 Context Switching 하여 다른 프로세스 2 를 수행할 수 있다.<br>이 상황에서 CPU는 데이터 전송에 너무 많은 시간을 할애하는 문제가 있다. 이를 해결하기 위해 CPU를 Device 데이터 이동에 사용하지 않고 I&#x2F;O를 위한 별도의 장치를 사용할 수 있는데 그것이 <strong>DMA</strong>(Direct Memory Access)이다.  </p>
<p>DMA는 특수목적 프로세서이다. CPU가 DMA에게 I&#x2F;O를 요청하면 DMA는 CPU를 대신하여 I&#x2F;O장치와 메인 메모리 사이 데이터전송을 수행한다.<br>CPU가 DMA에게 I&#x2F;O를 위임한다. DMA가 대신 I&#x2F;O를 수행해준다. CPU가 DMA에게 I&#x2F;O를 요청하면, DMA는 CPU를 대신하여 I&#x2F;O 장치와 메인 메모리 사이에 데이터 전송을 수행한다. CPU는 이 기간동안 다른 작업을 수행할 수 있다.
CPU는 Device에 직접 memory로 부터 data를 copy할 필요없이 DMA에게 copy할 메모리의 주소와 얼마나 전송할지를 알려준다. DMA는 I&#x2F;O를 대신 수행하고 완료되면 Interrupt를 발생시킨다.  </p>
<p align="center">
    <img style="max-width:600px" src="/images/os/schedule-with-dma.png"/>
</p>

<p>위 그림에서 Data copy에 걸리는 작업은 DMA가 수행하는 것을 볼 수 있다. CPU는 I&#x2F;O를 DMA에 요청하고 바로 다른 프로세스를 스케줄링하여 수행할 수 있다.  </p>
<p>DMA는 Memory Bus를 공유한다. CPU도 메모리에 접근하고 DMA도 메모리에 접근이 필요한데 메모리에 둘다 접근하려면 Bus를 통해 접근을 해야한다. 이 과정에서 둘이 충돌을 할 수 있는데 DMA는 CPU가 Bus 사용을 하지 않을 때 살짝살짝 사용한다. 이를 Bus stealing이라고 한다.  </p>
<p>예제로 Disk에 Read하는 과정을 보자. </p>
<p><strong>Disk Read 과정</strong>  </p>
<ol>
<li>CPU는 DMA Controller를 초기화하고 전송모드를 <code>DMA_MODE_READ</code>로 설정한다.</li>
<li>CPU는 DMA Controller에게 buffer(memory)의 주소(X)와 크기(C)를 알려준다.</li>
<li>DMA Controller는 Disk controller에게 데이터를 전송한다.</li>
<li>Disk controller는 매번 byte단위로 읽어오는 데이터를 DMA로 전송한다.</li>
<li>DMA Controller는 받은 데이터를 주소 X의 buffer에 기록한다. 매 전송마다 C값을 감소시키고 C&#x3D;0일때까지 전송받는다.</li>
<li>C가 0이되면 전송이 완료된 것이므로 DMA Controller는 전송이 완료되었음을 interrupt를 통해 CPU에 알린다.</li>
</ol>
<p>위 과정의 1번, 2번까지 하면 그 프로세스는 sleep 한다.  </p>
<p>I&#x2F;O가 끝나야 이를 호출한 process는 다음 step으로 넘어가는데 이를 synchronous I&#x2F;O model이라고 한다.<br>다른 I&#x2F;O model들도 있는데 이는 여기서는 범위가 넘어가므로 다루지 않을 예정이다.  </p>
<p>보통은 DMA가 CPU와 병렬적으로 같이 작동할 수 있기때문에 high performance가 필요할 때에는 더 좋다고 할 수 있다. 다만 DMA라는 장치가 필요하므로 조금 더 cost가 있다고 할 수 있겠다.</p>
<br/>
  
<h2 id="I-x2F-O-접근방법"><a href="#I-x2F-O-접근방법" class="headerlink" title="I&#x2F;O 접근방법"></a>I&#x2F;O 접근방법</h2><p>I&#x2F;O device에 접근하는 방법은 크게 2가지가 있다.  </p>
<ol>
<li><p>I&#x2F;O instruction을 사용한다.<br>  CPU가 제공하는 instruction을 통해서 장치의 register를 읽고 씀으로서 device 장치와 통신한다.<br>  예로는 intel의 I&#x2F;O instruction인 <code>in</code>, <code>out</code>, <code>ins</code>, <code>outs</code> 등이 있다.  </p>
</li>
<li><p>두번째로는 Memory Mapped I&#x2F;O를 사용하는 것이다.
  위에서도 살짝 언급했지만 Device 장치 register들을 memory 공간으로 mapping시키는 것이다.<br>  그냥 load, store 명령어를 통해 장치의 register를 읽고 쓸 수 있다. 다만 instruction 관점에서 I&#x2F;O instruction과 다른 점이 있는데, Memory Mapped I&#x2F;O 에서는 control register에 값을 쓰는게 1개의 instruction이 된다. I&#x2F;O instruction은 control register에 <code>READ</code>를 넣고 in register에 주소를 넣어주는 이런 일련의 동작들을 하나의 instruction으로 처리한다.<br>  Memory Mapped I&#x2F;O는 Memory space와 I&#x2F;O space를 구별하지 않는다. 최근의 Device들은 거의다 Memory Mapped I&#x2F;O를 지원한다.<br>  단, Memory Mapped I&#x2F;O를 위해서는 IO MMU(Input Output Memory Management Unit)라는 걸 사용해서 MMU가 CPU에서 보는 virtual memory address를 physical memory address로 바꾸어주듯 Device 입장에서 보는 virtual memory address를 physical memory address로 변환해주는 장치가 필요하다.</p>
</li>
</ol>
<br/>
  
<h2 id="Device-Driver"><a href="#Device-Driver" class="headerlink" title="Device Driver"></a>Device Driver</h2><p>각 device들은 서로다른 interface를 가지고있는데 어떻게 이들의 interface에 맞게 접근할 수 있을까?<br>파일시스템을 예로들면 파일시스템은 SSD, USB, SCSI disk 등의 위에서 작동할 수 있다. 하지만 우리는 이 각각의 매체에 의존하지 않고 block read, write을 하고싶은데 어떻게 이를 가능하게 할까?<br>이들위에 Abstraction layer을 둠으로써 가능하다. 위에 General한 Interface를 두고 이 Interface를 통해 접근하도록 한다.<br>하지만 결국에는 OS row level 어딘가에 각 device에 specific한 interface에 접근하는 코드가 존재를 해야한다. 이것이 바로 <strong>Device Driver</strong>이다.  </p>
<p>밑의 그림은 간단히 표현한 Linux Software 구조이다.  </p>
<p align="center">
    <img style="max-width:600px" src="/images/os/filesystem-stack.png"/>
</p>
  
<p>파일시스템은 단지 generic block layer를 바라보면서 block read, write 에 대한 요청만 수행하고 실제 disk 매체에 의존하지 않는다.<br>Block layer가 요청을 보고 적절한 device driver에 라우팅을 해준다.   </p>
<p>그림에서는 <strong>raw interface</strong>도 볼 수 있는데 이는 File Abstraction을 사용하지 않고 direct block read, write을 허용하게 해준다. 예를들어 파일조각모음 tool이나 file system checker 같은 소프트웨어들이 이 raw interface를 사용하여 구현한다.<br>다만 Generic 한 Interface에만 의존하기 때문에 단점도 존재하는데, 예를들어 SCSI는 detail한 error log을 볼 수 있도록 해준다. 하지만 generic interface에는 generic IO Error만 받을 수 있기때문에 SCSI의 이런 이점을 가져갈 수 없다.  </p>
<p>Device driver들의 구현코드들이 존재해야 이런 device들에 접근할 수 있기때문에 Kernel은 많은 Device driver 코드들을 가지고있다. 실제로 Linux kernel의 70% 정도가 device driver 코드들로 이루어져 있다.  </p>
<h4 id="IDE-Disk-Driver-예제"><a href="#IDE-Disk-Driver-예제" class="headerlink" title="IDE Disk Driver 예제"></a>IDE Disk Driver 예제</h4><p>실제 IDE Disk Driver의 예제를 가볍게 보자. 이를 보고나면 대략적으로 Device driver가 어떤 방식으로 이루어져 있는지 알 수 있을 것이다.  </p>
<p>먼저 IDE Interface는 다음과 같다.  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[Control Register]<br>    Address 0x3F6 = 0x08 (0000 1RE0): R=reset, E=0 means &quot;enable interrupt&quot;<br><br>[Command Block Registers]<br>    Address 0x1F0 = Data Port<br>    Address 0x1F1 = Error<br>    Address 0x1F2 = Sector Count<br>    Address 0x1F3 = LBA low byte<br>    Address 0x1F4 = LBA mid byte<br>    Address 0x1F5 = LBA hi byte<br>    Address 0x1F6 = 1B1D TOP4LBA: B=LBA, D=drive<br>    Address 0x1F7 = Command/status<br><br>[Status Register (Address 0x1F7)]<br>    7: BUSY, 6:READY, 5: FAULT, 4: SEEK, 3: DRQ, 2: CODE, 1: IDDEX, 0:ERROR<br><br>[Error Register (Address 0x1F1)&#125; (check when ERROR==1)<br>    7: BBK, 6:UNC, 5: MC, 4: IDNF, 3:MCR, 2: ABRT, 1: TONF, 0:AMNF<br><br>    BBK = Bad Block<br>    UNC = Uncorrectable data error<br>    MC = Media Changed<br>    IDNF = ID mark Not Found<br>    MCR = Media Change Requested<br>    ABRT = Command aborted<br>    T0NF = Track 0 Not Found<br>    AMNF = Address Mark Not Found<br></code></pre></td></tr></table></figure>

<p>IDE Disk은 4개의 register를 제공하는데 control, command, status, error register 들이다.<br>이 register들은 x86의 <code>in</code>, <code>out</code> instruction을 사용해 I&#x2F;O address를 명시함으로서 읽거나 쓸 수 있다.  </p>
<p>예를들어 Disk가 ready 상태인지 알기위해 위에 명시된 Status Register의 주소인 <code>0x1F7</code>을 읽어 READY 상태이면서 BUSY 가 아닌지 확인한다.<br>Command Register에 Write parameter를 쓰기 위해서는 sector count, sector의 LBA(Logical Block Address), drive number 등을 register에 각각 작성한다. 그리고 I&#x2F;O를 시작하려면 Command Register인 Address <code>0x1F7</code>에 WRITE command를 쓴다.<br>실제 데이터 전송을 위해서는 데이터를 전송해야하는데 데이터를 Data Port에 써준다.<br>Interrupt는 각 sector가 전송되면 발생하게 할수도 있고, 전체 전송이 완료되면 발생하게 할수도 있다.  </p>
<p>위에서 본 것은 IDE Disk의 Interface이고 이를 이용하는 Disk Driver를 작성해야한다.<br>이는 실제 구현된 IDE Disk Driver를 보면 이해가 쉽다.<br>IDE Disk Driver는 크게 4가지 주요한 함수가 있는데 각각 가볍게만 알아보도록 하자.  </p>
<h6 id="ide-rw"><a href="#ide-rw" class="headerlink" title="ide_rw()"></a>ide_rw()</h6><p>맨처음 read, write을 하기 위해 호출하는 함수이다.<br>다른 작업들이 있으면 요청을 queueing 하고 없으면 바로 다음함수인 <code>ide_start_request()</code>를 호출한다. 이를 요청한 프로세스는 여기서 sleep하도록 설정한다.  </p>
<h6 id="ide-start-request"><a href="#ide-start-request" class="headerlink" title="ide_start_request()"></a>ide_start_request()</h6><p>이는 read, write 요청을 disk에 전달하는 역할을 가진다. 여기서 device register에 in, out x86 instruction을 호출한다. 이 함수는 밑의 <code>ide_wait_ready()</code> 함수를 사용한다. 이는 요청을 device에 보내기 전에 ready 상태일때까지 기다린다.  </p>
<h6 id="ide-wait-ready"><a href="#ide-wait-ready" class="headerlink" title="ide_wait_ready()"></a>ide_wait_ready()</h6><p>ready 상태일때까지 busy waiting 한다.  </p>
<h6 id="ide-intr"><a href="#ide-intr" class="headerlink" title="ide_intr()"></a>ide_intr()</h6><p>Interrupt가 발생했을때 수행되는 함수이다. 만약 read 에 대한 interrupt였다면 device로부터 data를 읽어들이고 해당 read 요청을 한 프로세스를 깨운다. 그리고 다른 작업들이 queueing 되어있으면 다시 <code>ide_start_request()</code>를 호출한다.  </p>
<p>코드는 다음과 같다.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">ide_wait_ready</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Ready 상태일때까지 Busy waiting</span><br>    <span class="hljs-keyword">while</span> (((<span class="hljs-type">int</span> r = <span class="hljs-built_in">inb</span>(<span class="hljs-number">0x1f7</span>)) &amp; IDE_BSY) || !(r &amp; IDE_DRDY));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">ide_start_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> </span>&#123;<br>    <span class="hljs-built_in">ide_wait_ready</span>();<br>    <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x3f6</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// Enable interrupt</span><br>    <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1f2</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// Sector count 설정</span><br>    <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1f3</span>, b-&gt;sector &amp; <span class="hljs-number">0xff</span>); <span class="hljs-comment">// Logical block 설정</span><br>    <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1f4</span>, (b-&gt;sector &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>);<br>    <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1f5</span>, (b-&gt;sector &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>);<br>    <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1f6</span>, <span class="hljs-number">0xe0</span> | ((b-&gt;dev&amp;<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">4</span>) | ((b-&gt;sector&gt;&gt;<span class="hljs-number">24</span>)&amp;<span class="hljs-number">0x0f</span>));<br>    <span class="hljs-keyword">if</span>(b-&gt;flags &amp; B_DIRTY)&#123;<br>        <span class="hljs-comment">// This is write command</span><br>        <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1f7</span>, IDE_CMD_WRITE);<br>        <span class="hljs-built_in">outsl</span>(<span class="hljs-number">0x1f0</span>, b-&gt;data, <span class="hljs-number">512</span>/<span class="hljs-number">4</span>); <span class="hljs-comment">// Data transfer</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// This is read command</span><br>        <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1f7</span>, IDE_CMD_READ);<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ide_rw</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> </span>&#123;<br>    <span class="hljs-built_in">acquire</span>(&amp;ide_lock);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> buf **pp = &amp;ide_queue; *pp; pp = &amp;(* pp)-&gt;qnext); <span class="hljs-comment">// walk queue</span><br>    *pp = b; <span class="hljs-comment">// Queue의 tail에 request 추가</span><br>    <span class="hljs-keyword">if</span> (ide_queue == b) <span class="hljs-comment">// if q is empty</span><br>        <span class="hljs-built_in">ide_start_request</span>(b); <span class="hljs-comment">// send req to disk</span><br><br>    <span class="hljs-keyword">while</span> ((b-&gt;flags &amp; (B_VALID|B_DIRTY)) != B_VALID)<br>        <span class="hljs-built_in">sleep</span>(b, &amp;ide_lock); <span class="hljs-comment">// Process sleep</span><br><br>    <span class="hljs-built_in">release</span>(&amp;ide_lock);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ide_intr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">buf</span> *b;<br>    <span class="hljs-built_in">acquire</span>(&amp;ide_lock);<br>    <span class="hljs-keyword">if</span> (!(b-&gt;flags &amp; B_DIRTY) &amp;&amp; <span class="hljs-built_in">ide_wait_ready</span>() &gt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// Read 요청이면 device register에서 data를 읽어온다.</span><br>        <span class="hljs-built_in">insl</span>(<span class="hljs-number">0x1f0</span>, b-&gt;data, <span class="hljs-number">512</span>/<span class="hljs-number">4</span>);<br><br>    b-&gt;flags |= B_VALID;<br>    b-&gt;flags &amp;= ~B_DIRTY;<br>    <span class="hljs-built_in">wakeup</span>(b); <span class="hljs-comment">// 요청 process를 깨운다.</span><br>    <span class="hljs-keyword">if</span> ((ide_queue = b-&gt;qnext) != <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 다음 작업이 있다면 계속한다.</span><br>        <span class="hljs-built_in">ide_start_request</span>(ide_queue);<br><br>    <span class="hljs-built_in">release</span>(&amp;ide_lock);<br>&#125;<br></code></pre></td></tr></table></figure>
<br/>
   
<h2 id="번외"><a href="#번외" class="headerlink" title="번외"></a>번외</h2><ul>
<li><p>위의 I&#x2F;O instruction과 개념은 비슷하게 최근에 나온 neural processor는 metric 연산을 하나의 instruction을 제공한다.<br>기존의 metric 연산은 여러개의 instruction이 필요했는데 neural processor는 1개의 instruction으로 수행이 가능하다.  </p>
</li>
<li><p>Interrupt는 CPU clock 마다 작동할 수 있다. 다만 instruction이 수행중에는 interrupt가 발생할 수가 없다.<br>Instruction은 hardware와 software의 경계라고 볼 수 있다.
만약 instruction이 8 cycle이 걸린다고 하면, 그 8 cycle이 끝나는 시점에 interrupt가 발생한다. 이 instruction 중간에는 interrupt가 발생할 수 없다.</p>
</li>
</ul>
<h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul>
<li>Interrupt는 비동기적인 이벤트를 처리하기 위한 기법이다.</li>
<li>Trap은 잘못된 메모리주소 접근, system call 호출 등과 같은 동기적인 이벤트를 처리한다.</li>
<li>I&#x2F;O는 결국 Device register에 읽고 쓰는 것이다. DMA라는 하드웨어가 CPU대신 I&#x2F;O 작업들을 처리해줄 수 있다.</li>
<li>Memory Mapped I&#x2F;O를 사용하면 Device 장치 register들을 메모리 접근 instruction으로 읽고 쓸 수 있다.</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.amazon.com/Operating-Systems-Three-Easy-Pieces-ebook/dp/B00TPZ17O4">https://www.amazon.com/Operating-Systems-Three-Easy-Pieces-ebook/dp/B00TPZ17O4</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cs.unc.edu/~dewan/242/f96/notes/notes1/node13.html">http://www.cs.unc.edu/~dewan&#x2F;242&#x2F;f96&#x2F;notes&#x2F;notes1&#x2F;node13.html</a></li>
</ul>
<br/>
<br/>
<br/>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/OS/">OS</a></div><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-63138b1a1a412ebf" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/07/09/os-process/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">운영체제 4편 - 프로세스</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/07/09/os-virtualization/"><span class="level-item">운영체제 2편 - 가상화</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">댓글</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://tk-one.github.io/2019/07/09/os-computer-architecture/';
            this.page.identifier = '2019/07/09/os-computer-architecture/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'devtkone' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/tk-one-profile.jpeg" alt="TK-one"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">TK-one</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Seoul, South Korea</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">12</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/TK-one/" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/TK-one/"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/maven/"><span class="level-start"><span class="level-item">maven</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/network/"><span class="level-start"><span class="level-item">network</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/nodejs/"><span class="level-start"><span class="level-item">nodejs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/personal/"><span class="level-start"><span class="level-item">personal</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/tool/"><span class="level-start"><span class="level-item">tool</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0/"><span class="level-start"><span class="level-item">컴퓨터구조</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-07T13:21:13.000Z">2022-03-07</time></p><p class="title"><a href="/2022/03/07/coronavirus-confirmed/">코로나 확진후기</a></p><p class="categories"><a href="/categories/personal/">personal</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-05T12:59:06.000Z">2022-03-05</time></p><p class="title"><a href="/2022/03/05/how-to-use-markdown/">마크다운(Markdown) 사용법</a></p><p class="categories"><a href="/categories/tool/">tool</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-07T16:51:46.000Z">2020-09-08</time></p><p class="title"><a href="/2020/09/08/file-system-design/">파일시스템 5편 - 파일시스템 디자인-2</a></p><p class="categories"><a href="/categories/OS/">OS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-07T15:51:46.000Z">2020-09-08</time></p><p class="title"><a href="/2020/09/08/file-system-design-1/">파일시스템 4편 - 파일시스템 디자인-1</a></p><p class="categories"><a href="/categories/OS/">OS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-07T07:14:20.000Z">2020-09-07</time></p><p class="title"><a href="/2020/09/07/file-system-concept/">파일시스템 3편 - 파일시스템이란?</a></p><p class="categories"><a href="/categories/OS/">OS</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">3월 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">9월 2020</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">3월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">1월 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">8월 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">7월 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">2월 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">8월 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/coronavirus/"><span class="tag">coronavirus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/covid19/"><span class="tag">covid19</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/event-loop/"><span class="tag">event-loop</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/markdown/"><span class="tag">markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/maven/"><span class="tag">maven</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nodejs/"><span class="tag">nodejs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/smtp/"><span class="tag">smtp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/thread/"><span class="tag">thread</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0/"><span class="tag">컴퓨터구조</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C/"><span class="tag">파일시스템</span><span class="tag">6</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">업데이트 소식 받기</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="구독"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="기술블로그" height="28"></a><p class="is-size-7"><span>&copy; 2023 TK-one</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv">0</span>명의 사용자가 방문 함</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>