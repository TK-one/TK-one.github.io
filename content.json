{"pages":[],"posts":[{"title":"코로나 확진후기","text":"결론부터 말하자면 2022년 3월 3일 코로나19 양성판정을 받았다.계속 언제, 어디서부터 감염되었는지 생각해봤는데 아무리 생각해도 잘 모르겠다.간 곳이라고는 집앞에 있는 스터디카페밖에 없었고 그 스터디카페는 정말 큼지막해서 사람간의 동선도 거의 겹치지 않는다. 확진받은 날인 3월 3일 아침에 일어났을때 평소보다 목이 조금 잠겨있었다.이거 코로나인가..? 라고 생각은 들지 않았을만큼 아주 미세한 차이였고 그래도 뭔가 찝찝해서 아침에 집에 있는키트를 사용하여 진단해본 결과 음성이 나왔다.그래서 내가 확진되었다는 생각은 전혀 하지 못했지만, 오후에 갑자기 엄마가 확진판정을 받았다고 했다.그 말을 듣자마자 나도 바로 PCR검사를 받으러 갔고 결과는 다음과 같다. 흑흑흑..처음에 카톡으로 알림이 왔을때 나한테 잘못온줄 알았다.아니 내가 걸린다고?심지어 당일 아침에 자가진단키트로는 음성이 나왔어서 더 예상을 못했던 것 같다. 기가막히게 확진을 받은 다음날 새벽부터 오한이왔고 심한 목감기처럼 통증이 심해졌다.회사에도 현 상황을 공유해드리고 아픈건 맞지만 어차피 재택근무이고 업무하는데에는 무리가 없다는 개인적인 판단하에 계속해서 재택근무를 하기로 결정했다.감사하게도 회사에서 상비약을 마련해서 바로 퀵으로 보내주셨고 정말 많은 도움이 되었다.양도 굉장히 많아서 우리가족 다같이 나눠먹었다. 이제 자가격리가 3일 남았는데 얼른 끝났으면 좋겠다…공부해야될게 산더미인데 스터디카페를 못간다니..","link":"/2022/03/07/coronavirus-confirmed/"},{"title":"마크다운(Markdown) 사용법","text":"이번 포스트는 markdown에 대해 알아보는 포스트입니다.자주 사용하는 markdown 키워드들 위주로 정리하였습니다. Italics and Bolds Italics1this is _italic_ this is italic Bolds1this is **bold** this is bold Italics and Bolds1this is **_italics and bolds_** this is italics and bolds Headers Header 1부터 6까지 지원한다.123456# header 1## header 2### header 3#### header 4##### header 5###### header 6 header 1header 2header 3header 4header 5header 6Linkinline 링크와 reference 링크가 있다. inline link1[블로그 바로가기](https://tk-one.github.io) 블로그 바로가기 reference link123Here&apos;s [블로그 바로가기][my github].[my github]: https://tk-one.github.io Here’s 블로그 바로가기. Image이미지도 링크와 비슷하게 inline 이미지와 reference 이미지가 있다. inline image1![alt text](url) reference image123![alt text][markdown image][markdown image]: /images/markdown.png 이미지의 width와 height를 직접 지정해야 하는 상황이면 HTML의 img tag를 직접 사용한다. 1&lt;img src=&quot;/path&quot; width=&quot;500px&quot; height=&quot;300px&quot; /&gt; BlockQuotes BlockQuotes를 만들기 위해서는 앞에 caret(&gt;)을 넣어준다.1&gt; this is quotes. this is quotes. BlockQuotes안에서도 다른 markdown 문법을 사용할 수 있다.1&gt; this is _italic_. this is italic. Lists unordered list 1234* list 1* list 2* list 3* list 4 list 1 list 2 list 3 list 4 ordered list12341. list 12. list 23. list 34. list 4 list 1 list 2 list 3 list 4 nested list 1234567* parent 1 * child 1 * child 2* parent 2 * child 1 * child 2 * child 3 parent 1 child 1 child 2 parent 2 child 1 child 2 child 3 child’s child 1 nested list 에서도 indent를 맞추어 주고 싶을때는 다음과 같이 한다.1234567891. this is for indent.same indent. same indent 2.2. this is for number 2. same indent. &gt; do blockquotes. this is for indent.same indent. same indent 2. this is for number 2. same indent. do blockquotes. hr(수평선)수평선은 다음과 같이 나타낸다.1234* * *********- - - Paragraphs다음과 같은 문단을 작성한다고 해보자.123this is paragraph.this is sentence 1.this is sentence 2. 하지만 이를 markdown으로 렌더링하면 줄바꿈이 되지 않고 다음과 같이 보인다. this is paragraph.this is sentence 1.this is sentence 2. 줄바꿈을 하려면 여러가지 방법이 있는데 첫번째는 hard break 라고 불리는 방법을 사용하는 것이다.12345this is paragraph.this is sentence 1.this is sentence 2. this is paragraph. this is sentence 1. this is sentence 2. soft break 방식은 다음과 같다.123this is paragraph.··this is sentence 1.··this is sentence 2.·· (여기서의 ·은 space를 의미한다.)즉, 줄의 마지막에 space 2개를 붙여주면 된다. this is paragraph.this is sentence 1.this is sentence 2.","link":"/2022/03/05/how-to-use-markdown/"},{"title":"Maven(메이븐) 이란?","text":"이 글은 박재성님이 쓰신 자바세상의 빌드를 이끄는 메이븐이라는 책과 메이븐 공식문서를 보고 정리한 글입니다.책이 있으신분은 메이븐 개념을 한번 머릿속에 정리하고 싶을때 읽으시면 매우 좋습니다. 책에 스토리로 이끌어가는 부분이 있어 매우 재밌게 읽을 수 있습니다.다만, 책이 절판되어 책을 구하고싶으신 분들은 아마 알라딘이나 다른 곳에서 중고서적으로 구매를 하셔야 합니다. Maven메이븐은 자바기반 프로젝트를 빌드하고 관리하기 위한 툴이다.요즘은 Gradle이 많이 쓰이지만 아직 maven을 사용하고 있는 프로젝트도 많다.메이븐은 빌드 프로세스를 최대한 쉽게 하는것을 목표로 하고 이 뿐만 아니라 프로젝트에 질높은 정보를 제공하고, 단일 빌드시스템을 제공하는 것을 목표로 한다. 다른 build tool 없이 자바프로젝트를 개발하게 되면 의존성관리 등 신경써야할게 한두가지가 아니다. 메이븐이 이를 도와준다.메이븐의 장점은 다음과 같다. 편리한 의존관계 관리를 지원한다. 모든 프로젝트가 일관된 프로젝트 디렉토리 구조, 빌드 프로세스를 유지할 수 있다. 다양한 메이븐의 플러그인을 활용할 수 있다. 프로젝트의 template을 만들수있다. 메이븐은 저장소를 지원해서 메이븐만 설치하면 프로젝트 build에 필요한 라이브러리, plugin을 저장소에서 우리의 PC로 자동으로 다운로드한다. 다운로드한 라이브러리들은 특정 디렉터리에 위치하게 되는데 이를 localRepository(로컬저장소)라고 부른다. 기본적으로는 ~/.m2/repository 에 위치하고 settings.xml로 설정을 변경할 수도 있다.또 메이븐은 처음 생성하는 프로젝트 종류에 따라 기반이 되는 template을 제공한다. 이를 이용해서 메이븐 기반 프로젝트를 생성할 수 있는데, 그러면 프로젝트의 기본적인 뼈대를 자동으로 생성할 수 있다. 메이븐의 이 같은 기능을 archetype이라고 한다. 메이븐 공식문서의 getting started에서 처음 메이븐 프로젝트를 만들게 될때도 archetype을 사용한다.다음 명령어로 메이븐 프로젝트를 생성해보자.1mvn -B archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 이를 실행하면 my-app 프로젝트의 디렉터리가 만들어지고 그 안에 pom.xml 파일이 생성된다.메이븐은 source code와 test code를 분리해서 관리하는데 source code는 src/main/java 에 위치하고, test code는 src/test/java 에 위치한다.여기서 사용한 groupId, artifactId는 뒷부분에서 다루겠다. 메이븐 기본명령어메이븐 명령어는 다음과 같은 형태를 가진다.mvn [options] [goal] [phase]위의 명령어에서도 사용했던 -D 옵션들은 메이븐 설정파일(pom.xml)에 인자를 전달한다.예를 들어 단위테스트를 실행하지 않으려면 mvn -Dmaven.test.skip=true [&lt;phase&gt;]와 같이 실행할 수 있다.메이븐에는 phase와 goal 개념이 있는데 이들을 이용하며 빌드를 실행할 수 있고, 빌드를 실행할 때 여러개의 phase와 goal을 실행할 수 있다. 예를들어 다음과 같이 다양한 형태로 실행이 가능하다.mvn clean test: clean phase와 test phase를 실행한다.mvn clean compiler:compile: clean phase와 compiler plugin의 compile goal을 실행한다.phase와 goal은 밑에서 자세히 다루겠다. Pom.xml위의 메이븐 archetype:generate 명령어로 메이븐 프로젝트를 생성했으면 pom.xml 파일이 생성된다. POM은 Project Object Model을 의미한다. 그러면 pom.xml의 각 element 들을 살펴본다. 먼저 생성된 pom.xml은 다음과 같다.12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;maven-app&lt;/name&gt; &lt;!-- FIXME change it to the project&apos;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; .. 이하생략 .. project: pom.xml의 최상위 element modelVersion: POM version. 최근버전이 4.0.0이다. artifactId: project를 식별하는 id를 의미한다. groupId 안에서 여러개의 project가 있을 수 있다. groupId: project를 생성하는 조직의 고유 id를 결정한다. 도메인 이름을 많이 사용하는데 꼭 그럴필요는 없다.groupId + artifactId는 값이 유일해야한다. 그렇지 않으면 중앙저장소에서 충돌한다. packaging: 어떤 방식으로 패키징할지 결정한다. jar, war 등을 설정가능하다. version: project의 현재 버전을 의미한다. 프로젝트 개발중에는 SNAPSHOT을 suffix로 사용가능하다.SNAPSHOT은 maven의 예약어이며 SNAPSHOT을 사용하면 라이브러리를 다른방식으로 관리한다. name: project 이름이다. url: project url이 있다면 이를 기입한다. dependencies: 프로젝트와 의존관계에 있는 라이브러리들을 관리한다. 각 프로젝트의 pom.xml은 기본적으로 최상위 POM이라고 불리는 설정을 상속한다. 그래서 pom.xml의 설정내용이 단순하더라도 메이븐의 기본 규약들을 전부다 따르는 것이 가능하다. 실제 정의된 설정들을 보려면 다음 명령어를 사용하면 된다.mvn help:effective-pom설정되어있는 repository 정보를 담고있는 repositories 태그, plugin 설정정보를 담는 태그등 기존 pom.xml에 보이지 않았던 태그들을 볼 수 있다. 이 내용들이 기본적으로 최상위 POM에 존재했기 때문에 우리가 만든 project의 pom.xml은 단순하게 가져갈 수 있다. Lifecycle메이븐은 모든 빌드 단위가 이미 정의되어 있으며 이는 개발자가 임의로 변경할 수가 없다.여기서 말하는 빌드 단위란 compile, test, package, deploy 등을 말한다.메이븐은 이와같이 미리 정의되어 있는 빌드 순서를 lifecycle이라고 하며 메이븐은 3개의 lifecycle을 제공한다. compile, test, package, deploy를 담당하는 기본 lifecycle 빌드 결과물 제거를 위한 clean lifecycle project document site를 생성하는 site lifecycle이다. 메이븐은 기본적으로 빌드후의 모든 산출물을 target 디렉터리에서 관리한다. target 디렉터리에 생성되는 하위디렉터리는 다음과 같다. target/classes: src/main/java의 소스코드가 컴파일된 class 파일들과 src/main/resources 디렉터리의 자원이 복사된다. target/test-classes: src/test/java의 소스코드가 컴파일된 class 파일들과 src/test/resources 디렉터리의 자원이 복사된다. target/surefire-reports: report 문서들이 위치한다. 기본 Lifecycle기본 lifecycle을 활용해 source code를 compile, test 등을 할 수 있는데 각 phase들을 살펴보면 다음과 같다. process-resources: src/main/resources의 모든 자원을 target/classes 로 복사한다. compile: src/main/java에 있는 source code를 compile한다. process-test-resources: src/test/resources의 모든 자원을 target/test-classes 로 복사한다. test-compile: src/test/java에 있는 source code를 compile한다. test: Junit 같은 unit test framework로 test를 진행하고 test가 실패하면 빌드실패로 간주한다.결과물을 target/surefire-reports 디렉터리에 생성한다. package: pom.xml의 packaging 값에 따라 압축한다.(jar, war) install: local repository에 압축한 파일을 배포한다. deploy: 원격저장소에 압축한 파일을 배포한다. 이처럼 maven 기본 lifecycle은 여러개의 phase로 구성되어 있으며, 각 phase는 의존관계를 가진다.process-resources ← compile ← process-test-resources ← test-compile ← test ← package이 순으로 의존관계를 가지고 있어서 package phase를 실행(mvn package)하면 의존관계에 있는 test phase가 먼저 실행되고, test phase는 compile phase에 의존관계가 있기때문에 compile phase가 먼저 실행된다.따라서 package phase를 실행하면 process-resources → compile → process-test-resources → test-compile → test → package 순으로 빌드가 진행된다. process-resources phase는 src/main/resources 에 있는 모든 자원을 test/classes 디렉터리로 복사하는데,만약 다른 디렉터리에도 자원이 존재한다면 pom.xml에 따로 설정할 수 있다. package phase는 jar나 war형태로 압축하여 target 디렉터리에 위치시킨다.&lt;build&gt;/&lt;finalName&gt;에 값이 설정되어 있으면 {finalName}.{packaging} 형태로 압축파일이 생기고,값이 설정 안되어있다면 {artifactId}-{version}.{packaging} 형태로 된다. clean phase는 빌드한 결과물들을 제거하는 phase인데 이는 다른 phase와 관련이 없다.clean phase를 실행하지 않고 다른 phase를 실행할 때 불필요한 산출물들 때문에 오류가 날 수 있으므로 clean을 실행하고 빌드하는 습관을 가지면 좋다. Clean Lifecycleclean lifecycle은 빌드를 통해 나온 산출물을 모두 삭제한다.target directory를 삭제하는 것과 동일하다. Site Lifecyclesite lifecycle은 사용안하는 경우가 많은데 핵심만 짚고 넘어가자면,site, site-deploy phase를 사용해 실행가능하다. site lifecycle은 메이븐에 설정되어 있는 기본설정, 플러그인 설정에 따라 target/site directory에 문서 사이트를 생성한다. site-deploy는 이를 배포한다. Plugin메이븐에서 제공하는 모든 기능은 plugin을 기반으로 동작한다.메이븐 phase 또한 메이븐 plugin을 통하여 실질적인 작업이 실행된다. 따라서 phase가 실행되는 과정을 이해하려면 maven plugin을 먼저 이해해야 한다. 사용하고자 하는 maven plugin이 있다면 pom.xml에 다음과 같이 설정한다.1234567891011&lt;project&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 이와 같이 사용하고자 하는 plugin의 groupId, artifactId, version을 명시하면 된다.version을 생략하면 가장 최신버전의 plugin이 설치된다.메이븐 plugin은 하나의 plugin에서 여러 작업을 실행할 수 있도록 지원하는데 여기서 각각 실행할 수 있는 작업을 goal이라고 정의한다.위의 compiler plugin은 하나지만 이 플러그인이 지원하는 goal은 compile(source directory의 compile), testCompile(test directory의 compile) 등이 있다. plugin은 다음과 같이 실행할 수 있다.mvn groupId:artifactId:version:goal 예를들어 앞의 compiler plugin의 compile goal은 다음과 같이 실행한다.mvn org.apache.maven.plugins:maven-compiler-plugin:2.1:compile 만약 settings.xml에 pluginGroup이 설정이 되어있다면 groupId를 생략이 가능하고,version을 생략하면 local repository에 있는 가장 최신 버전의 플러그인을 사용하며,plugin 이름이 maven-$name-plugin 이나 $name-maven-plugin 형식을 따른다면 $name 값만 명시할 수 있다.앞에서 실행했던 compile 플러그인을 다음과 같이 실행할 수 있다.mvn compiler:compile 앞부분에서 실행했던 mvn archetype:generate 명령도 mvn org.apache.maven.plugins:maven-archetype-plugin:generate를 축약한 것이다. 메이븐은 매우 많은 플러그인들을 활용할 수 있는게 큰 장점이다. 다양한 플러그인을 제공하고 있어서 원하는 개발환경을 얼마든지 만들어 나갈 수 있다. Phase와 Goal메이븐에서 phase는 build lifecycle에서 각 단계와 순서를 정의하는 개념으로 실제로 빌드작업을 하지는 않는다.실제 빌드작업은 해당 phase와 연결되어 있는 plugin의 goal에서 진행한다.mvn compile은 compile phase를 실행한 것인데 이는 compile phase와 연결되어 있는 compiler plugin의 compile goal이 실행되면서 컴파일 작업을 진행한다.기본 lifecycle에서 phase를 실행할 때 기본으로 연결된 plugin의 goal을 실행하는 구조이다.기본 lifecycle에서 phase에 연결되어 있는 plugin을 실행할 때에는 자동으로 메이븐 중앙저장소에서 plugin을 다운로드 한다. phase와 goal과의 관계를 보여주는 그림이다. 각 핵심 phase 별로 구체적인 내용을 알아보자. mvn compilecompile phase를 실행하면 먼저 의존관계에 있는 process-resources phase가 먼저 실행된다. process-resources phase는 src/main/resources 디렉터리에 있는 모든 자원을 target/classes 디렉터리로 복사한다.만약 src/main/java 안에서도 소스와 같은 패키지로 관리하는 리소스들이 있고 이들또한 target/classes에 복사되기를 원한다면 다음과 같은 설정을 하면된다.12345678910111213&lt;project&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/project&gt; 그러면 compile phase 실행시 src/main/java에 있는 *.java 파일을 제외한 모든 설정파일을 target/classes 로 복사한다.resource plugin과 compiler plugin 에 대한 자세한 정보는 다음 공식문서에서 확인할 수 있다.resources plugin : resources-plugincompiler plugin : compiler-plugin mvn testtest phase를 실행하면 process-test-resources phase가 먼저 실행되면서 src/test/resources 디렉터리의 자원복사를 먼저 진행한다.그리고 test-compile phase에서 src/test/java 디렉터리의 test code들을 컴파일한다.test phase는 target/test-classes 에 컴파일한 단위 테스트 클래스를 실행하고 그 결과물을 target/surefire-reports 디렉터리에 생성한다.기본적으로 test phase는 target/test-classes 에 있는 모든 단위 테스트 클래스를 실행하는데 특정 테스트 suite 별로 실행할 필요가 있다면 test option을 사용할 수 있다. mvn -Dtest=MyUnitTest test이와 같이 특정 테스트 클래스만 실행할 수 있고 여러개의 test 클래스 들을 실행하고 싶다면 쉼표로 여러개를 정의하면된다. mvn packagepackage phase는 compile, test-compile, test, package 순으로 실행된 후 jar, war 파일이 target 디렉터리 하위에 생성된다.&lt;build&gt;/&lt;fileName&gt; 에 값이 설정되어 있고 jar로 패키징을 하게되면 {finalName}.jar 형태로 jar 파일이 생성된다. 만약 finalName element가 설정되어 있지 않다면 {artifactId}-{version}.{packaging} 이 압축파일 그리고 디렉터리 이름이 된다.예를들어, finalName element가 설정되어있지 않고 pom.xml 설정이 다음과 같다면123456&lt;project&gt; &lt;groupId&gt;io.github.tk-one&lt;/groupId&gt; &lt;artifactId&gt;myapp&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/project&gt; 파일은 다음 위치에 생성된다.target/myapp-1.0-SNAPSHOT/myapp-1.0-SNAPSHOT.war mvn installinstall phase는 package phase와 의존관계에 있기때문에 package phase를 먼저 실행한다. package phase에서 jar or war 파일로 압축을 완료하면 이를 local repository에 배포한다. mvn deploydeploy phase는 jar or war 파일을 원격저장소에 등록한다. 라이브러리 의존관계메이븐은 의존관계에 있는 라이브러리를 관리하기 위해 의존 라이브러리 관리기능을 제공한다. 이는 메이븐의 lifecycle과 더불어 메이븐의 핵심기능이기 때문에 반드시 이해하는게 좋다. 메이븐 저장소는 로컬저장소와 원격저장소로 나뉜다. 로컬저장소로컬저장소는 개발자 PC에 있는 저장소로 메이븐을 빌드할때 다운로드하는 라이브러리나 플러그인을 관리 및 저장한다.로컬저장소는 기본값으로는 ~/.m2/repository 에 위치한다. 원격저장소원격저장소는 외부에 위치하는 저장소로 사내에서 사용하는 저장소도 있고 중앙저장소라고 불리는 오픈소스 라이브러리나, 메이븐 플러그인 등을 저장하고 있는 저장소도 있다. 중앙저장소는 원격저장소 중 하나라고 생각하면 된다. 메이븐은 빌드를 할때 로컬저장소에 이미 다운로드한 라이브러리가 있으면 원격저장소에서 다운로드 하지않고 로컬저장소에 있는 라이브러리르 사용한다. 메이븐이 다운로드 하고자 하는 저장소는 repositories 태그로 설정할 수 있다.기본적으로 우리가 repositories 태그로 설정을 안하고 다운로드할 수 있는 이유는 최상위 POM에 이미 정의가 되어있기 때문이다.123456789&lt;project&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 여러개의 repository들을 추가할 수 있는데 그러면 메이븐은 라이브러리를 다운로드할때 repositories 태그에 있는 저장소 순서대로 다운로드를 시도한다. 위에서 생성한 myapp에서는 다음과 같이 dependencies 태그로 라이브러리를 관리한다.12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 이와 같이 설정하고 빌드하면 메이븐은 먼저 로컬저장소에 해당 라이브러리가 있는지 확인한다.없다면 메이븐은 중앙저장소에서 junit 4.11 버전이 있는지 확인하고 있다면 jar 파일을 로컬저장소에 다운로드한다.중앙저장소에 해당 라이브러리와 버전이 존재하는지 확인할 때에는 위에 repository 설정에 적힌 url을 바라보고https://repo.maven.apache.org/maven2/junit/junit/4.11/junit-4.11.jar 파일이 있는지를 파악한다.이와 같이 설정하고 빌드하면 메이븐은 중앙저장소에서 junit 4.11 버전의 jar 파일을 로컬저장소에 다운로드한다.로컬저장소에 다운로드 받는 위치는 기본적으로 다음과 같다.~/.m2/repository/junit/junit/4.11/junit-4.11.jar 그리고 메이븐은 로컬저장소에 다운로드한 라이브러리를 활용해 src/main/java 그리고 src/test/java 에 있는 source code들을 컴파일한다. version을 LATEST 혹은 RELEASE로 설정할 수도 있는데 그러면 항상 가장 최신버전의 라이브러리와 의존관계를 갖게된다.또, 한번 로컬저장소에 다운로드한 라이브러리는 다시 원격저장소에서 다운로드하지 않는데 이부분에서 애플리케이션이 개발단계에 있어 코드가 지속적으로 변경되는 상황이라면 SNAPSHOT을 활용하자.version 정보에 SNAPSHOT을 포함하게되면 빌드할 때마다 가장 최근에 배포한 라이브러리가 있는지 확인하고 로컬저장소에 있는것보다 최신일경우 이를 다운로드한다. scope메이븐에서는 사용하는 라이브러리의 성격에 따라 scope를 지정할 수 있다.JUnit 라이브러리의 경우 실제 배포할때는 필요없고 테스트를 진행할때만 필요하다. 이런경우 scope를 test로 주면된다. scope는 6가지 종류가 있다. compile: default scope이다. compile 및 deploy시 같이 제공해야하는 라이브러리이다. provided: compile 시점엔 필요하지만 deploy에 포함할 필요는 없는경우 사용한다. runtime: compile에는 필요없지만 runtime에는 필요한 경우 사용한다. test: test 시점에만 사용하는 라이브러리에 설정한다. system: provided scope와 비슷한데 로컬저장소에서 관리되는 jar파일이 아닌 우리가 직접 jar 파일을 제공해야한다. import: 다른 pom.xml 에 정의되어있는 의존관계설정을 가져온다. Dependency MechanismDependency Mechanism은 메이븐의 핵심중 하나이다.그러므로 메이븐이 어떻게 의존성을 관리하는지는 꼭 이해하고 넘어가는게 좋다. Dependency Transitive(의존성 전이)프로젝트에서 의존하는 라이브러리들의 숫자는 제한이 없지만 의존성 cycle이 있으면 문제가 발생한다.프로젝트에 외부 라이브러리를 하나씩 추가할때마다 그 라이브러리가 또 의존하고있는 라이브러리를 또 추가해야 하므로 의존관계에 있는 라이브러리 숫자가 증가한다.예를들어, project A가 B, C에 의존하고있다면 B가 의존하고있는 D, E, F 라이브러리가 또 필요할 것이고 또 D 가 의존하는 G 라이브러리도 필요할 것이다. 연쇄작용으로 의존하는 프로젝트는 점점 커진다.참고로 메이븐은 의존성이 있는 라이브러리가 또 어떤 라이브러리에 의존성을 가지고있는지 알기위해 jar 파일을 다운로드 하는 동시에 해당 라이브러리의 pom파일도 같이 다운로드 한다.메이븐은 위처럼 프로젝트 라이브러리 숫자가 급격히 증가하는 문제점을 해결하기 위해 라이브러리 제한이 가능하도록 의존성 전이 설정을 지원한다. Dependency mediation: 같은 의존성의 여러버전을 마주치게 되었을때 artifact의 어떤 버전을 사용할지 결정한다.메이븐은 이때 더 가까운 의존관계에 있는 버전의 의존관계를 선택한다.예를들어 다음과 같은 의존성이 있다고 가정한다. 123456 A├── B│ └── C│ └── D 2.0└── E └── D 1.0 이 예에서는 A를 build할때 D 1.0이 사용된다. 왜냐하면 A -&gt; B -&gt; C -&gt; D 2.0 보다 A -&gt; E -&gt; D 1.0 이 더 가깝기 때문이다.여기서 서로 depth 가 같은 상황이라면 먼저 명시된 라이브러리의 버전이 사용된다.만약 project A의 pom.xml에 직접 version을 적어주면 그 버전을 사용한다. 12345678 A├── B│ └── C│ └── D 2.0├── E│ └── D 1.0│└── D 2.0 이처럼 A에 직접 D 2.0 의 의존성을 추가하면 D 2.0 을 사용한다. Dependency management: 메이븐의 &lt;dependencyManagement&gt; element로 의존관계에 있는 artifact의 버전을 직접 명시랄 수 있다. Dependency scope: 현재 빌드상태에 맞는 라이브러리만 의존관계를 포함한다.즉, test scope를 가지는 경우 최종 배포산출물을 빌드하는 시점에는 포함되지 않는다. Excluded dependencies: 만약 A -&gt; B -&gt; C와 같이 의존성이 있으면 project A에서 명시적으로 project C에 대한 의존성을 &lt;exclusion&gt;태그를 사용해 명시적으로 제외시킬 수 있다. Optional dependencies: 만약 A -&gt; B -&gt; C와 같이 의존성이 있고 project B에 C가 optional로 설정이 되어있으면 project A를 빌드할때 project C에 대한 의존관계를 가지지 않는다. 메이븐의 Dependency Transitive가 의존관계를 최대한 잘 설정해 주겠지만 pom.xml에 항상 라이브러리의 명확한 version을 명시하는게 좋다.현재 프로젝트에서 의존하고있는 라이브러리의 tree를 보고싶다면 다음 plugin의 goal을 사용하면 좋다.mvn dependency:tree Propertypom.xml에서 발생하는 중복설정은 속성(property)를 정의하여 개선할 수 있다.보통 공통된 버전관리에 많이 사용하고는 하는데 예제를 보면 바로 이해할 수 있다.12345678910111213&lt;project&gt; &lt;properties&gt; &lt;spring.version&gt;3.0.1.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&gt;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 속성은 &lt;properties&gt; element에서 &lt;property.name&gt;value&lt;/property.name&gt; 형태로 정의한다.그리고 이렇게 정의한 내용은 pom.xml 파일내에서 ${property.name} 으로 접근할 수 있다.","link":"/2020/03/24/maven-basic/"},{"title":"Node.js의 Buffer를 제대로 이해해보자","text":"이 글은 Daajust의 Do you want a better understanding of Buffer in Node.js? Check this out. 글을 번역 한 글입니다. 모든 저작권과 권리는 Daajust에게 있습니다. 곳곳에 의역이 들어가있는 점 양해부탁 드립니다 :) Node.js에서 Buffer, Stream, Binary Data 를 마주치게 될때면, 이것들을 아예 모르는 사람들도 있고, 늘 이 개념에 대해 두려워하는 사람도 있으며, 자기 자신이 이를 정확하게 이해 하고있는지도 종잡을 수 없는 사람도 많습니다. 이 내용들은 nodejs 시니어나 package 모듈 개발자정도는 되어야 다룰 수 있을 것 같은 기분이 듭니다. 실제로, Node.js 자체의 소스코드나 유명라이브러리들의 소스코드를 까보시면, Buffer을 안마주칠 확률보다 마주칠확률이 더 높습니다. 특히 컴퓨터공학과정을 거치지 않은사람이, nodejs로 개발 할때에 저런 단어들을 마주칠때면 더욱 두려움을 느끼곤 합니다. 안타깝게도, 시중에 있는 많은 Node.js 개발서적들은 Node.js의 핵심기능들이나 그 기능구현의 이유에 대해 설명하기도 전에, 바로 Node.js 패키지들을 이용해서 Web Application을 구현하는 방법에 대해 설명합니다.그리고 어떤사람들은 뻔뻔하게도, Buffer, Stream, Binary Data 같은 것들은 어차피 다룰 일이 없을 것이기 때문에, 알 필요도 없다고 주장합니다. 물론 스스로 그저그런 Node.js 개발자로 살기로 선택한 사람이라면, 이런것들을 마주칠 일은 없을 수도 있습니다. 그게아니라, Node.js에 대해 더 깊이 이해하고 싶거나, 도대체 Buffer 같은 Node.js 의 핵심기능에 대해 궁금하고 더 알고싶은 호기심이 들면, 바로 이것이 제가 글을 쓰는 이유입니다 :) 이 글에선 Node.js의 핵심기능중 일부를 설명하고, 이 글을 읽게되면 Node.js에 대한 이해가 한 차원 더 높아질 것입니다. Node.js 공식문서에서는 Buffer를 다음과 같이 정의합니다. 바이너리 데이터들의 스트림을 읽거나, 조작하는 매커니즘.이 Buffer클래스는 Node.js의 일부로 도입되어 TCP 스트림이나 파일시스템같은 작업에서의 octet 스트림과의 상호작용을 가능하기 위해 만들어졌습니다.* octet Stream은 일반적으로 8bit 형식으로 된 데이터를 의미합니다. 음.. 정의를 읽어보니 약간 말이 복잡합니다.이 말을 쉽게 풀어쓰면 즉, Buffer클래스는 바이너리 데이터들의 스트림을 직접 다루기 위해 Node.js API에 추가되었습니다.라고 볼 수 있습니다. 그래도 말이 좀 간단해 졌죠 ? 하지만 아직까지는 Buffer, Stream, Binary Data .. 이런 단어들이 확 와닿지는 않습니다.이제부터 처음부터 끝까지 이것들을 살펴봅시다. Binary Data ? 이게 뭔가요?우리는 컴퓨터가 이진수로 데이터를 저장하고 표현한다는걸 이미 알고있습니다. 이진수는 단순히 1과 0의 집합입니다. 예를들어, 다음은 서로 다른 이진수 5개이며, 이 이진수들은 서로다른 1과 0의 집합입니다. 10, 01, 001, 1110, 00101011 각각 이진수에서 1 혹은 0으로 되어있는 자리를 비트(bit)라고 합니다. 이는 Binary digIT의 약자입니다. 컴퓨터가 어떤 데이터를 저장하거나 표현하기 위해서는, 컴퓨터는 해당 데이터를 이진수로 변환해야합니다.예를들어, 숫자 12를 변환하려면 컴퓨터는 12를 이진수인 1100로 변환해야합니다. 하지만 우리가 다루는 데이터중에는 숫자만 있는것은 아닙니다. 우리가 다루는 데이터중에는 문자열도 있고 이미지, 비디오형식도 있습니다. 컴퓨터는 모든 유형의 데이터를 이진수로 변환하는 법을 알고 있습니다.문자열을 예시로 들어봅시다.어떻게 컴퓨터가 문자열 ‘L’을 이진수로 나타낼까요 ? 어떤 문자를 이진수로 나타내기 위해서는 첫번째로 그 문자를 숫자로 변환해야 합니다. 숫자로 변환하면 그 숫자를 이진수로 변환하면 끝나기 때문이죠.컴퓨터는 문자열 ‘L’에 대해서 먼저 ‘L’을 나타내는 숫자로 변환합니다. 어떻게 변환할까요?웹브라우저 콘솔을 열어 이 코드를 실행시켜보세요 : 'L'.charCodeAt(0)숫자 76이 출력되나요? 이 숫자는 문자 ‘L’을 나타내는 숫자 값입니다. 이는 Character Code 혹은 Code Point 라고 불립니다. 그렇다면 컴퓨터는 어떻게 이 문자를 보고 바로 매칭해서 숫자를 알려줄 수 있었을까요? 어떻게 문자 ‘L’을 보고 숫자 76을 알려줄 수 있었을까요? Character Set (문자 집합)Character Set은 각각문자를 숫자로 나타낼 수 있도록 정의해놓은 규칙입니다. 위에 보았듯이 ‘L’을 76으로 매칭할 수 있게 각각문자에 해당하는 숫자를 표로 정리해놓은 것이라고 보시면 됩니다. 그렇다고 한가지 Character Set 만 있는것은 아니고 여러가지 Set들이 있습니다. 이중에서 유명한 것은 우리가 자주 들어본 유니코드, 아스키코드 가 있습니다. 자바스크립트는 유니코드와 아주 궁합이 잘맞습니다. 사실은 브라우저에서 ‘L’을 76으로 표현한 것은 유니코드입니다. 이렇게 우리는 어떻게 컴퓨터가 문자를 숫자로 표현하는지 보았습니다. 이제는, 컴퓨터가 숫자 76을 이진표현로 변환할 것입니다. 우리는 그냥 단지 숫자 76을 이진수로 변환하면 될 것이라고 생각합니다. 과연 그럴까요? Character Encoding (문자인코딩)문자를 숫자로 나타내는 것에 규칙이 있는 것 처럼, 숫자를 바이너리 데이터로 나타내는 데에도 규칙이 있습니다. 정확히 말하면, 숫자를 몇 bit로 나타낼 것인가를 정하는 것입니다. 이것을 Character Encoding 이라고 부릅니다.Character Encoding의 정의중 하나가 UTF-8 입니다. UTF-8은 문자가 바이트단위로 인코딩 되어야 합니다. 1바이트는 8개 비트의 집합을 의미합니다. 즉 8개의 1 또는 0을 의미합니다. 그래서 문자를 바이너리로 나타내는데에는 8개의 1과 0으로된 집합이 사용됩니다. 위에 언급한 내용을 다시 이어나가자면, 숫자 12을 이진수로 나타내면 1100 입니다. UTF-8 명세에 따르면 숫자 12는 8bit로 구성되어야 합니다. 8bit로 구성하려면 12의 실제 이진수 표현의 왼쪽에 더 많은 bit를 추가해서 바이트로 만들면 됩니다.그래서 12는 00001100 으로 저장될 것입니다.이것이, 컴퓨터가 숫자 혹은 문자를 바이너리 데이터로 저장하는 방식입니다.이것과 비슷하게, 이미지나 비디오데이터 또한 바이너리 데이터로 저장하는 방식도 따로 정해져 있습니다. 이중에 핵심은, 컴퓨터는 모든 데이터를 바이너리 이진 데이터로 저장한다는 것입니다. Character Encoding 에 대해 더 자세히 알고싶으시다면, Character Encoding에 대해 자세히 알아보기를 한번 보시는걸 추천합니다. 우리는 이제 바이너리 데이터가 무엇인지를 알았습니다. 그렇다면 바이너리 데이터의 Stream은 무엇일까요 ? StreamNode.js 에서의 스트림은 간단하게 한 지점에서 다른 지점으로 이동하는 일련의 데이터를 의미합니다. 전체적인 의미로는, 만약 우리가 어떤 방대한 양의 데이터를 처리해야 할때, 모든 데이터가 전부다 사용가능 할때까지 기다리지 않아도 된다는 것입니다. 기본적으로 큰 데이터는 청크단위로 세분화되어 전송됩니다. 이말은, 처음 설명했던 Buffer의 정의에 따르면, 파일시스템에서 바이너리 데이터들이 이동한다는걸 의미합니다. 예를들어, file1.txt의 텍스트를 file2.txt로 옮기는 걸 의미합니다. 하지만, Streaming 하는동안에 buffer라는 것이 어떻게 바이너리 데이터를 다룰 수 있게 도와준다는 것일까요? 정확히 buffer는 무엇일까요? Buffer우리는 데이터들의 스트림이란 일련의 데이터들이 한지점에서 다른 지점으로 이동하는 것이라는 걸 배웠습니다. 하지만, 데이터들이 정확하게 어떻게 이동한다는 것일까요?일반적으로 데이터의 이동은 그 데이터를 가지고 작업을 하거나, 그 데이터를 읽거나, 무언가를 하기 위해 일어납니다. 하지만 한 작업이 특정시간동안 데이터를 받을 수 있는 데이터의 최소량과 최대량이 존재합니다. 그래서 만약에 한 작업이 데이터를 처리하는 시간보다 데이터가 도착하는 게 더 빠르다면, 초과된 데이터는 어디에선가 처리되기를 기다리고 있어야 합니다. 데이터를 처리하는 시간보다 훨씬빠르게 계속해서 새로운 데이터가 도착하면 어딘가에는 도착한 데이터들이 미친듯이 쌓일것이기 때문이죠. 반면에, 한 작업이 데이터를 처리하는 시간이 데이터가 도착하는 시간보다 더 빠르다면, 먼저 도착한 데이터는 처리되기 전에 어느정도의 데이터량이 쌓일때까지 기다려야 합니다. 바로 그 기다리는 영역이 buffer 입니다! 컴퓨터에서 일반적으로 RAM이라고 불리는 영역에서 streaming 중에 데이터가 일시적으로 모이고, 기다리며 결국에는 데이터가 처리되기위해 내보내어 집니다. Streaming과 Buffer의 과정을 버스정류장에 빗대어 설명할 수 있습니다. 어떤 버스정류장에서는, 어느정도 이상의 승객이 모이지 않거나, 출발시간 전일때에는 출발하지 않습니다. 그리고, 승객들은 버스정류장에 도착하는 속도도 도착하는 시간도 각각 다릅니다. 승객 자기자신도 버스도 그 어느 누구도 버스정류장에 승객이 도착하는걸 마음대로 제어할 수 없습니다. (승객이 버스정류장에 도착하는 것도 결국에는 승객 스스로 제어하는게 아니라 환경적 요인에 달려있다는 말입니다.)어쨌든 일찍 도착한 승객은 버스가 출발하기 전까지는 버스정류장에서 기다려야 합니다. 반대로 승객이 도착했을때, 버스가 이미 문을닫고 출발하기 직전상태 이거나 버스가 이미 출발한 상황일때에는 다음 버스를 기다려야 합니다. 어떤 경우든지, 승객이 기다리는 위치가 있습니다. 바로 버스정류장입니다. 바로 그게 Node.js에서의 Buffer입니다! Node.js는 데이터가 도착하는 시간이나 전송되는 속도를 제어할 수는 없습니다. Node.js가 결정할 수 있는건 언제 데이터를 내보내느냐 입니다. 버스를 언제 출발시킬 수 있는 제어권이 있는 것과 동일합니다. 아직 데이터를 내보낼 때가 아니면, Node.js는 데이터들을 일종의 대기영역인 RAM에 작은 영역인 buffer에 데이터를 넣어놓습니다. 일상생활에서 버퍼작동을 볼 수 있는 예로는 온라인 영상을 시청할 때 입니다. 유튜브를 보는 순간을 상상해보세요. 우리의 인터넷 연결상태가 매우 좋을때에는 영상 스트리밍이 끝날때까지 버퍼를 채우고 데이터가 처리될 수 있게 빠르게 내보내고, 다시 버퍼를 채우고 빠르게 내보내고를 반복합니다. 그러나 인터넷 연결상태가 좋지 못할때에는 첫번째 데이터셋을 처리하고 나서, 영상플레이어는 로딩 아이콘을 띠우면서 ‘buffering’이라는 텍스트를 보여줄 것입니다. 이것은 데이터가 더 모이고 도착할때 까지 기다린다는 의미입니다. 만약에 버퍼가 채워지고 데이터가 처리되면, 영상이 다시 보여지게 될 것입니다. 영상을 보여주는 동안에도, 계속해서 다음 데이터가 도착하고, 버퍼에 채워질 것입니다. 이것이 바로 버퍼입니다. 아까 보았듯이 버퍼에 대한 설명에서, 데이터가 버퍼에 있는동안 우리가 streaming되는 바이너리 데이터들을 조작하고 다룰 수 있다고 했습니다. 우리가 이런 raw한 바이너리 데이터들을 이용해서 어떤 종류의 작업을 할 수 있을까요? Node.js에서 구현한 Buffer 문서에는 우리가 다룰 수 있는 작업 내용들을 리스트로 정리해서 보여줍니다. 그 중에 몇가지를 살펴봅시다. 버퍼다루기우리는 직접 Buffer를 만들 수도 있습니다. Node.js는 Streaming 하는동안에 자동으로 Buffer를 만드는데요. 이것말고도 우리가 직접 Buffer를 만들고 직접 다룰 수 있습니다. 흥미롭죠? 한번 저희가 직접 만들어봅시다! 버퍼를 만드는데는 여러가지 방법이 있습니다. 한번 보시죠. 12345678// size가 10인 빈 buffer를 만듭니다. // 이 버퍼는 오직 10 byte만 담을 수 있습니다.const buf1 = Buffer.alloc(10);// buffer 에 데이터를 담아 만듭니다.const buf2 = Buffer.from(&quot;hello buffer&quot;); 버퍼를 만들었으면, 이제 마음대로 조작할 수 있습니다. 123456789101112131415161718192021222324252627282930// 버퍼구조를 조사합니다.buf1.toJSON();// { type: &apos;Buffer&apos;, data: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] }// 빈 버퍼입니다buf2.toJSON();// { type: &apos;Buffer&apos;, data: [ 104, 101, 108, 108, 111, 32, 98, 117, 102, 102, 101, 114 ] }// toJSON 메서드는 데이터를 Unicode Code Points 로 표현합니다.// 버퍼의 크기를 조사합니다.buf1.length // 10buf2.length // 12. 파라미터로 넣어주었던 content에 따라 자동으로 크기가 할당됩니다.// 버퍼에 쓰기buf1.write(&quot;Buffer really rocks!&quot;);// 버퍼를 Decoding 합니다.buf1.toString(); // &apos;Buffer rea&apos;// buf1 은 10 byte 밖에 담을 수 없기 때문에, 나머지 문자들은 할당할 수 없습니다. 우리는 버퍼로 많은 것들을 할 수 있습니다. 이들은 nodejs 공식문서에서 전부 확인할 수 있습니다. 마지막으로, 과제를 하나 남기고 가겠습니다. Node.js 핵심 라이브러리들중 하나인 zlib.js의 소스코드를 분석하여, 어떻게 버퍼를 활용하여 바이너리 데이터 스트림을 다루었는지 확인해보세요. 우리는 버퍼를 배웠기때문에 이제 두려울게 없습니다. 이건 사실 gzip을 구현한 것입니다. 코드분석을 하면서, 새로 알게된 것들을 글로도 한번 적어보시고, 댓글로도 같이한번 의견을 나눠보았으면 좋겠습니다 :) 이 글이 Node.js 의 Buffer를 이해하는데 도움이 되었으면 좋겠습니다. 혹시, 이 글이 도움이 되었고, 남들에게도 이 글을 알려드리고 싶으시다면 원본 Medium article에 클랩한번 눌러주세요! 감사합니다.","link":"/2018/08/28/nodejs-buffer/"},{"title":"Node.js 이벤트루프 제대로 이해하기","text":"이 글은 Daniel Khan의 What you should know to really understand the Node.js Event Loop 글을 번역 한 글입니다. 모든 저작권과 권리는 Daniel Khan에게 있습니다. 곳곳에 의역이 들어가있는 점 양해부탁 드립니다 :) Node.js 는 이벤트 기반의 플랫폼입니다. 이 말은 즉슨, 노드에서 일어나는 모든 일은 어떤 이벤트에 대한 반응이라는 말과 같습니다. Node에서 일어나는 모든 처리는 전부 일련의 콜백내용들입니다. libuv 라는 추상화된 라이브러리가 이벤트루프라는 기능을 제공합니다. 이 이벤트루프는 아마 오해하기 가장 쉬운 개념일 것입니다. 저는 성능 모니터링 제작업체인 Dynatrace에서 일하며, 이곳에서 이벤트루프 모니터링에 대한 작업을 할때, 실제로 우리가 무엇을 측정하고 있는지 제대로 이해하기 위해서 많은 노력을 기울였습니다. 이 글에서는, 이벤트루프가 실제로 동작하는 방식과 어떻게 이를 올바르게 모니터링 하는 방법에 대해 다룰 예정입니다. 이벤트루프에 대한 오해Libuv는 Node.js에 이벤트루프를 제공하는 라이브러리 입니다. libuv의 코어 개발자였던 Bert Belder가 발표했던 Node 동작방식에 대한 강연에서, 우리가 이벤트루프를 구글에 검색했을때 나오는 이미지들과 그 이미지에서 설명하는 이벤트루프 동작방식들에 대해 이는 대부분이 틀렸으며 실제로 이렇게 동작하지 않는다고 설명합니다. 이제 우리가 할 수 있는 가장 흔한 오해들 부터 설명해보겠습니다. 오해 1: 이벤트루프는 우리가 실제로 작성한 코드와는 별개로 별도의 스레드에서 실행됩니다.오해우리가 작성한 자바스크립트를 코드를 실행시켜주는 main 스레드가 존재하고, 이벤트루프를 실행하는 또다른 쓰레드가 존재합니다. 비동기 작업이 실행 될 때마다, main 스레드는 이벤트루프 스레드에게 작업을 넘겨주고, 작업이 완료되면 이벤트루프 스레드가 main 스레드에게 신호를 보내 콜백을 실행합니다. 실제자바스크립트를 실행시키는 스레드는 단 하나뿐이며, 이 스레드가 바로 이벤트루프가 실행되는 스레드입니다. Node.js 어플리케이션에서 실행되는 사용자의 코드는 전부 콜백이라고 볼 수 있습니다. 이 콜백함수의 실행은, 이벤트루프에 의해 수행됩니다. 이 내용은 조금 뒤에서 깊이 다룰 예정입니다. 오해 2: 모든 비동기 작업은 스레드 풀에서 처리합니다.오해파일I/O나 외부와 통신하는 HTTP통신이나 데이터베이스통신같은 비동기 작업들은 항상 libuv가 제공하는 스레드 풀에서 수행됩니다. 실제Libuv는 기본적으로 비동기작업을 수행하기 위해 4개의 스레드를 스레드 풀에 할당하여 놓습니다. 현대의 OS들은 많은 I/O 작업들을 위해 비동기 Interface들을 제공합니다. 이 예로는 Linux의 AIO가 있습니다.Libuv는 가능하다면, 직접 OS의 비동기 Interface를 사용하며, 스레드풀에 작업을 넘겨주지 않습니다.데이터베이스 같은 서드파티시스템에도 동일합니다. DB 드라이버를 이용해 스레드풀을 활용하지 않고, 비동기 인터페이스를 직접 사용합니다.즉, 다른 방법이 없는 경우에만, libuv는 비동기 작업들을 스레드 풀에 할당합니다. 오해 3: 이벤트 루프는 스택 or 큐 같은 것입니다.오해비동기 작업들은 FIFO(선입선출 큐)에 쌓이고, 이벤트루프는 이 큐를 계속 돌면서, 태스크가 완료되었을 때 콜백을 실행합니다. 실제이벤트루프에 큐 형식의 자료구조가 포함되있는건 맞습니다. 하지만 이벤트루프는 이 큐를 돌면서 실행하지 않고, 스택을 처리합니다. 이벤트루프는 round-robin 방식으로 차례차례 돌면서 처리되는 특정 작업들의 단계들로 이루어져 있습니다.약간 말이 어려운데요. 밑에서 자세히 다뤄보겠습니다. 이벤트루프 작업 이해하기이벤트루프를 이해하기 위해서는, 각 단계에 어떤 작업들이 수행되는지를 알아야 합니다.이벤트루프가 어떻게 실행되는 지는 다음과 같습니다. 여기서 초록색 박스는 이벤트루프의 각 단계들을 의미합니다.이 단계들을 하나씩 살펴보겠습니다. 자세한 설명은 Node.js 공식문서에 한국어로 아주 잘 설명되어있으니, 읽어보시면 도움이 될 것입니다. TimerssetTimeout() 또는 setInterval()에서 스케줄링된 모든 것은 여기서 처리됩니다. 하지만 그 타이머 안에 등록한 콜백함수의 실행은 Polling 단계의 가장 앞부분에서 이루어집니다. IO Callbacks대부분의 콜백들이 여기서 처리됩니다. 사용자가 작성한 Node.js의 모든 코드는 기본적으로 콜백입니다.(예: HTTP 요청에 의한 콜백함수는 다시 여러개의 콜백함수를 실행시킵니다.)Node.js 공식문서에서 설명하는 이벤트루프의 각 단계별 역할에 대한 내용이 이 글의 원본에 적혀있는 내용과 달라 정정합니다.Timers단계의 다음 단계인 Pending Callbacks 라고 불리는 단계에서는, TCP오류 같은 시스템 작업의 콜백을 반환합니다. 예를들어, TCP 소켓이 연결을 시도하다가 ECONNREFUSED 같은 메시지를 받으면, 이에 대한 오류보고를 위해 이에 대한 콜백함수가 IO Callbacks (pending callbacks) 단계의 큐에 추가됩니다. IO Polling이벤트루프가 Poll 단계에 진입하면,먼저 Timers 단계에 스케줄링 되었던 콜백들 중에, 시간이 지난 타이머의 콜백을 실행합니다.그 다음, Poll 단계의 큐에 있는 이벤트들을 처리합니다. 대부분의 콜백들은 이 Poll 단계에서 처리됩니다. Set Immediate (=Check)setImmediate()를 통해 등록된 모든 콜백을 실행됩니다. Close‘close’ 이벤트에 대한 모든 콜백이 실행됩니다. 이벤트루프 모니터링Node.js 어플리케이션에서 진행되는 모든 작업은 이벤트루프를 통해 실행됩니다. 이 말은 즉슨, 이 이벤트루프에 대한 메트릭을 측정할 수만 있다면, 이 정보들을 이용해 Node.js 어플리케이션에 대한 전반적인 상태나 성능에 대한 중요한 정보들을 알아낼 수 있습니다.이벤트루프에서 런타임때 메트릭 정보들을 가져올 수 있는 API가 없기때문에, 각 모니터링 툴들이 직접 자기들만의 메트릭을 구축하여 이벤트루프에 대한 모니터링을 제공합니다. 여기서 우리가 이를 어떻게 해결했는지 한번 보겠습니다. Tick Frequency시간마다 tick 수입니다. Tick Duration1번의 tick에 걸리는 시간을 의미합니다. 실상황에서 Tick 빈도수와 Tick 소요시간 지표우리가 서로 다른레벨의 부하테스트를 줘봤을 때, 결과는 놀라웠습니다. 예제를 보여드리겠습니다. 다음 시나리오에서는 다른 HTTP 서버로 외부요청을 보내는 express.js 노드 프로그램을 호출합니다. 네가지 시나리오가 있습니다. Idle들어오는 요청이 없습니다. ab -c 5Apache bench를 이용하여 한번에 5개의 요청을 생성합니다. ab -c 10한번에 10개의 요청을 생성합니다. ab -c 10 (느린 백엔드)서버가 요청보내는 외부 HTTP 서버는 요청을 받으면 1초 후에 응답을 반환하도록 하여, 느린 백엔드를 만들었습니다. 이렇게 하면, 노드서버가 HTTP 서버로부터 응답을 기다리면서 흔히 말하는 back pressure가 발생합니다. 이 결과 차트를 보면, 재밌는 내용을 발견 할 수 있습니다. 이벤트루프 tick 수행시간과 빈도는 동적으로 조정됩니다. 노드 어플리케이션에 아무런 요청도 없는 상태인 경우, (타이머, 콜백 등) 대기중인 작업이 없는 상태로서, 위에서 설명했던 모든 단계들(timers, I/O callbacks, polling 등)을 미친듯이 계속 도는게 아니라 이벤트루프가 이에 적응하고 polling 단계에서 새로운 콜백이 등록되기를 잠시 기다립니다. 즉, 요청이 없을때에는 이벤트루프의 tick 빈도는 적고 tick의 duration은 긴 상황입니다. 이 상황에서의 지표는 이후에 진행한 느린 백엔드에서 진행했던 지표와 유사합니다. 이 노드 어플리케이션은 5개의 요청을 한번에 요청했던 시나리오에서 최고로 좋은 성능을 냅니다. 결과적으로, tick 빈도나 tick duration을 보고 분석할 때에는 노드 서버의 초당요청 수를 기준삼아 보아야합니다. 이 지표들은 우리에게 의미있는 내용들을 제공해주긴 했지만, 아직까지는 실제로 어느 단계(phase)에서 시간이 소비되었는지 알지 못하기 때문에 두가지 측정항목이 더 필요합니다. 작업 처리 지연시간작업처리 지연시간은 비동기 작업이 스레드 풀에서 처리 될 때까지 걸리는 시간을 의미합니다. 여기서 지연시간이 길다면, 이는 libuv 스레드 풀의 사용량이 많고 굉장히 바쁘다는 것과 같습니다. 이 지연되는 시간을 측정하기 위해, express.js 노드 어플리케이션에 Sharp 라이브러리를 이용하여 이미지를 가공하거나 처리해주는 API를 추가했습니다. 이미지처리는 부하가 있는 작업이기에, Sharp 라이브러리는 스레드 풀을 사용합니다. 그래프를 보면, Apache bench를 이용하여 5개의 요청을 동시에 보냈을때 이미지처리가 있는 요청과 그 전에서 진행했던 일반적인 HTTP서버 처리가 있는 요청은 확실하게 구별됩니다. 이벤트루프 지연시간이벤트루프 지연시간은 setTimeout(X)로 스케줄링 된 작업이 실제로 처리될 때 까지 추가로 소요되는 시간을 의미합니다. 이벤트루프 지연시간이 높다는 것은, 이벤트루프가 콜백을 처리하기 엄청 바쁜 상태라는 것과 같습니다. 이 이벤트루프 지연시간 측정을 위해, 이번에는 굉장히 비효율적인 알고리즘으로 피보나치를 계산하는 API를 추가했습니다. Apache bench를 이용해 피보나치를 계산하는 API로 부하를 주면 콜백 큐가 바쁘다는 걸 알 수 있습니다. 우리는 이러한 4가지 주요 메트릭(Tick Frequency, Tick duration, 작업처리 지연시간, 이벤트루프 지연시간)으로 Node.js 내부동작을 더 잘 이해할 수 있게 되었고, 꽤 중요한 내용들도 알게되었습니다. 이벤트루프 튜닝물론, 이 메트릭 정보들만으로 문제를 해결 할 수는 없습니다. 실제 이벤트루프가 고갈되었을때, 어떻게 대응 해야하는지 알아봅시다. 모든 CPU 활용Node.js 어플리케이션은 싱글 스레드로 작동합니다. 멀티코어 환경에서 1개의 Node.js 어플리케이션은 효율적으로 작동하지 않습니다. 낭비되는 CPU가 있기 때문입니다. Cluster Module을 사용하면, CPU 마다 child 프로세스를 쉽게 만들 수 있습니다. 각각의 child 프로세스는 각자 자신만의 이벤트루프가 존재하고 master 프로세스는 모든 자식들에게 요청을 분산시켜 줍니다. 스레드 풀 조정앞서 언급했듯이, libuv는 스레드 4개로 스레드 풀을 생성합니다. 스레드 풀의 기본 크기는 UV_THREADPOOL_SIZE 환경변수를 설정해서 수정할 수 있습니다. 이 방법은 I/O 작업이 많은 어플리케이션에서 도움이 될 수 있겠지만, 큰 스레드 풀은 메모리나 CPU를 고갈시킬 수 있음을 기억해야 합니다. 작업을 다른서비스에 맡기기만약 Node.js가 CPU사용이 과도하게 필요한 작업에서 사용된다면, 이 특정 작업에 더 잘맞는 다른 언어를 선택해서 그 쪽으로 처리를 옮겨 작업량을 줄이는 것이 가능한 방법일 수 있습니다. 요약 이벤트루프는 Node.js를 실행시켜주는 것이다. 이벤트루프의 기능을 잘못 알고 있는 경우가 많습니다 - 몇가지 단계들을 차례대로 반복하면서 순서대로 각 단계들의 작업들을 처리해나갑니다. 이벤트루프 자체에서 제공해주는 메트릭이 없으므로, 수집된 메트릭들은 APM 제품들마다 다릅니다. 이벤트루프 메트릭들은 병목현상에 대해 중요한 정보들을 제공해주지만, 이벤트루프와 실행중인 코드에 대한 깊은 이해가 가장 중요합니다. 감사합니다.","link":"/2019/02/07/nodejs-event-loop/"},{"title":"인터넷 메일시스템 (SMTP)","text":"이 포스트에서는 Application Layer의 SMTP (Simple Mail Transfer Protocol) 에 대해 알아본다.먼저, SMTP를 보기전에 인터넷 전자메일 시스템이 어떤식으로 동작하는지 알고있어야 한다. Mail System인터넷 메일 시스템은 크게 user agent, 메일서버, SMTP 이 3가지 요소로 구성되어 있다.아래의 그림을 보면서 이해하면 쉽다. user agentMS의 Outlook을 생각하면 쉽다. user agent는 사용자가 메일을 읽고, 작성하고, 전송할 수 있도록 해준다. 메일서버사용자가 메일 작성을 끝내면 user agent는 메시지를 메일서버로 보내게되고, 여기서 메시지는 메일서버의 output 메시지큐에 들어가게 된다.여기서의 메일서버는 송신자의 메일서버를 의미한다.송신자의 메일서버에서 수신자의 메일서버로 메시지가 전송되면, 메일들은 수신자의 메일서버안의 메일박스(mailbox)안에 저장되고 유지된다.만약, 수신자의 메일서버가 다운된 상황에서 송신자가 메일을 보내면 어떻게 될까?송신자가 메일을 전송하면, 먼저 메일이 송신자의 메일서버에 도착한다. 그리고 송신자의 메일서버는 메일을 수신자의 메일서버로 전송할 수 없을때, 메시지 큐(message queue)에 보관하고 있다가, 주기적으로 메일전송을 시도한다. SMTPSMTP는 Application layer에서 작동하는 메일전송 프로토콜이다. 위의 메일서버 설명에서, 한 메일서버에서 다른 메일서버로 메시지(메일)을 전송할때 사용하는 프로토콜이 SMTP이다.이뿐만 아니라, 송신자의 user agent에서 본인의 메일서버로 메일을 전송할때도 SMTP가 사용된다.SMTP는 TCP위에서 작동한다. 참고로 SMTP는 HTTP보다 훨씬 더 오래전부터 사용되었다. 이 설명을 기반으로 메일을 전송하는 간단한 시나리오를 보자.A가 B에게 메일을 전송하는 상황이다. A가 user agent를 통해 B에게 메일 내용을 작성하고 전송버튼을 누른다. A의 user agent는 메시지를 A의 메일서버에 보내게 되고, 메시지는 메일서버의 output message queue에 위치한다. A의 메일서버에서 동작하는 SMTP 클라이언트는 output message queue에 쌓여있는 메시지를 B의 메일서버로 전송하기 위해 먼저 TCP연결을 맺는다. TCP가 맺어진 후, SMTP 핸드쉐이킹을 하고 SMTP 프로토콜에 따라 B의 메일서버로 전송한다. B의 메일서버는 메시지를 수신한 후, 그 메시지를 B의 메일박스(mailbox)에 놓는다. B는 이후에 user agent를 실행하여 메일을 읽을 수 있다. 인터넷 메일 시스템은 대충 이런식으로 작동한다.(2번에서 A의 user agent가 메시지를 A의 메일서버로 보낸다고 되어있는데, 사실 여기서도 SMTP 프로토콜을 통해 전달된다.)그러면 이제 SMTP를 좀 더 자세히 보도록 한다. SMTP (Simple Mail Transfer Protocol)대부분의 Application layer protocol 처럼 SMTP는 송신자의 메일서버에서 수행하는 클라이언트와, 수신자의 메일서버에서 수행되는 서버를 가지고 있다. 메일서버가 상대 메일서버로 전송할때는 SMTP의 클라이언트로 동작하는 것이고, 메일서버가 상대 메일서버로 부터 메일을 받을때는 SMTP 서버로 동작하는 것이다. HTTP를 떠올리면 쉽다. 메일서버에서 상대 메일서버로 메일을 보내는 상황에서, 먼저 클라이언트 SMTP는 서버 SMTP의 25번 포트로 TCP연결을 맺는다. 만약 서버가 죽어있으면 클라이언트는 나중에 다시 시도한다.TCP 연결이 맺어지면, 클라이언트와 서버는 SMTP 핸드쉐이킹을 수행한다. 이 SMTP 핸드쉐이킹 과정에서 클라이언트는 송신자와 수신자의 email 주소를 제공한다. 핸드쉐이킹 과정을 마치면, 클라이언트는 메시지를 보낸다. SMTP 클라이언트와 SMTP 서버 사이의 메시지 전달과정을 예를들어 살펴보자.클라이언트 호스트네임은 github.io 이고, 서버 호스트네임은 korea.ac.kr 이라고 하자.C는 클라, S는 서버를 나타내고 TCP 연결 직후의 상황을 가정한다.메일 내용은 “Hello, this is TK-one. Can I know the result of the interview?” 이다. S: 220 korea.ac.krC: HELO github.ioS: 250 Hello github.io, pleased to meet youC: MAIL FROM: tk-one@github.ioS: 250 tk-one@github.io … Sender okC: RCPT TO: kim@korea.ac.krS: 250 kim@korea.ac.kr … Recipient okC: DATAS: 354 Enter mail, end with “.” on a line by itselfC: Hello, this is TK-one. (메일내용)C: Can I know the result of the interview? (메일내용)C: .S: 250 Message accepted for deliveryC: QUITS: 221 korea.ac.kr closing connection 클라이언트는 5개의 명령(HELO, MAIL FROM, RCPT TO, DATA, QUIT)을 내리며 하나의 점(.)으로 된 라인을 송신하면 이는 메시지의 끝을 의미한다.서버는 각 명령에 대해 답하며, 각 응답은 응답코드와 옵션 설명을 갖고 있다.그리고 주의할 점이 있는데, SMTP는 메시지의 body와 header를 포함하여 전부 7bit ASCII 코드로 작성되어야 한다.HTTP는 이런 제한이 없는 반면, SMTP는 한글이나 binary 데이터 처럼 ASCII가 아닌 문자를 포함한다면 반드시 이 메시지는 전송되기 전에 7bit ASCII로 인코딩이 되어야한다. 이렇게 SMTP를 통해 한 메일서버에서 다른 메일서버로 메시지가 전달된다.그렇다면 수신자는 자신의 PC에서 user agent를 통해 자신의 메일서버에 있는 메시지들을 어떻게 얻을 수 있을까?수신자의 user agent는 메일을 가져오기위해 SMTP를 사용할 수는 없다. 왜냐하면 SMTP는 푸시(push)용 프로토콜인 반면, 메시지를 가져오는 것은 풀(pull) 동작이기 때문이다.여기서는 메일서버로부터 자신의 user agent로 메시지를 가져오기 위해 특별한 메일 접속 프로토콜을 사용한다. 이들중엔 POP3(Post Office Protocol - Version 3), IMAP(Internet Mail Access Protocol), HTTP 등이 있다.참고: Computer Networking - A Top-Down approach","link":"/2020/01/03/smtp/"}],"tags":[{"name":"cleancode","slug":"cleancode","link":"/tags/cleancode/"},{"name":"formatting","slug":"formatting","link":"/tags/formatting/"},{"name":"이펙티브자바","slug":"이펙티브자바","link":"/tags/이펙티브자바/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"hadoop","slug":"hadoop","link":"/tags/hadoop/"},{"name":"hdfs","slug":"hdfs","link":"/tags/hdfs/"},{"name":"socket","slug":"socket","link":"/tags/socket/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"oop","slug":"oop","link":"/tags/oop/"},{"name":"kqueue","slug":"kqueue","link":"/tags/kqueue/"},{"name":"process","slug":"process","link":"/tags/process/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"covid19","slug":"covid19","link":"/tags/covid19/"},{"name":"coronavirus","slug":"coronavirus","link":"/tags/coronavirus/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"event-loop","slug":"event-loop","link":"/tags/event-loop/"},{"name":"smtp","slug":"smtp","link":"/tags/smtp/"}],"categories":[{"name":"books","slug":"books","link":"/categories/books/"},{"name":"Hadoop","slug":"Hadoop","link":"/categories/Hadoop/"},{"name":"os","slug":"os","link":"/categories/os/"},{"name":"personal","slug":"personal","link":"/categories/personal/"},{"name":"tool","slug":"tool","link":"/categories/tool/"},{"name":"maven","slug":"maven","link":"/categories/maven/"},{"name":"nodejs","slug":"nodejs","link":"/categories/nodejs/"},{"name":"network","slug":"network","link":"/categories/network/"},{"name":"cleancode","slug":"books/cleancode","link":"/categories/books/cleancode/"},{"name":"이펙티브자바","slug":"books/이펙티브자바","link":"/categories/books/이펙티브자바/"}]}